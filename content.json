{"pages":[],"posts":[{"title":"Algorithm study_01","text":"title: 내용","link":"/2019/04/22/Algorithm-study-01/"},{"title":"TIL-190402","text":"2일차(0402) - HTML/CSSHTML/CSS - What I learn… CSS 레이아웃 선택자 레벨(점수) Table Position 브라우저 접두사 CSS 기초 상속의 이해 겹침의 개념 우선순위 레이아웃 position float display DOM Tree란? 선택자 파워 element &lt; class &lt; id &lt; inline-style Color Font font-size, font-weight, font-variant, line-height(특징 알기), font-family 브라우저별 지원 형식이 다름 rem, em, px 차이 알아보기 Table Position relative, absolute, fixed, sticky 각각의 특징 알기 브라우저 접두사 -webkit, -ms, -o, -moz","link":"/2019/04/02/TIL-190402/"},{"title":"TIL-190403-git blog 시작하기","text":"Hexo git blog 시작하기Node 설치Hexo를 사용하려면 Node 설치가 필요하다. 여기 를 통해 다운로드가 가능하다. Hexo 설치Command를 통해 해당 디렉토리에 명령어를 통해 설치하기 $ npm install hexo-cli -g 만약 설치를 하지 못한다는 에러 메세지가 출력 된다면 앞에 “sudo”를 붙여 보자. Hexo 초기 설정$ Hexo init (folder name) $ cd (folder name) $ npm install Blog 파일로 접속Hero new post “제목“Hero generateHero serverHero deploy 원하는 폴더에서 Hexo init [blog]Npm installHexo new post “#”","link":"/2019/04/03/TIL-190403-git-blog-시작하기/"},{"title":"TIL-190404","text":"3일차(0404) - HTML/CSSHTML/CSS - What I learn… CSSs CSS 레이아웃 선택자 레벨(점수) Table Position 브라우저 접두사 nav 한 페이지에 2~3개 정도가 적당 메인메뉴임을 알 수 있도록 으로 제목 넣어줄 것(section, article 동일) gradient background 속성 중 하나 linear-gradient() text-shadow white-space nowrap background-position animation - @keyframe","link":"/2019/04/04/TIL-190404/"},{"title":"TIL-190405","text":"4일차(0405) - HTML/CSSHTML/CSS - What I learn… # form fields legend label (input 요소에 for 속성으로 연결) a tag(title, target, a 태그의 중요성) text-indent letter-spacing clearfix(모듈) .clearfix::after {content: “”; display: block; clear: both;}","link":"/2019/04/05/TIL-190405/"},{"title":"TIL-190408","text":"5일차(0408) - HTML/CSSHTML/CSS - What I learn… # dl, dt, dd display: flex 크로스브라우징의 중요성 HTML5 Shiv - WEBDIR :: HTML5 Shiv - HTML5 요소 크로스브라우징","link":"/2019/04/08/TIL-190408/"},{"title":"TIL-190406-CSS-reset","text":"css reset study html basic css a “*“ ::befer / ::after-","link":"/2019/04/06/TIL-190406-CSS-reset/"},{"title":"TIL-190409","text":"6일차(0409) - HTML/CSSHTML/CSS - What I learn… # 날짜 정의 datetime 속성 - 필수 속성, 컴퓨터가 날짜를 확인 text-overflow overflow: hidden, white-space: nowrap 함께 써야 함 defer 속성 removeClass addClass e.keycode https://keycode.info/","link":"/2019/04/09/TIL-190409/"},{"title":"TIL-190410-html markup 설계하기 ","text":"HTML - basicHTML이란?Hyperlink text Markup Language 약자로 웹 페이지를 구성하는 틀에 역활을 한다. 웹 디자인 인지 사항HTML는 단지 외관적으로 뿐만 아니라 내부적으로 관리가 용이하고, 간결한 CSS 설계를 위해 많은 신경을 써야 한다. 또한 많은 스타트업은 빠른 성장을 위해 웹 페이지 디자인에 접근성을 놓치는 일이 많다. 그러나 요즘 대기업, 혹은 해외 기업과 스타트업들은 장애인에 접근성을 높이기 위해 노력하는 일이 늘어나고 있다. 웹 표준 (Web Standard)W3C (World Wide Consortium)에서 정의하는 기술 표준을 말한다. 사용성과 접근성에 더 높은 초점을 가지고 웹 계발과 다양한 환경에 사용자의 이용을 보장한다. 웹 접근성 (Web Accessibility)모든 환경에 사용자에게 같은 서비스 제공하며 이용에 차별이 없도록 보장하는 것. 주로 시각, 마우스를 사용하지 못하는 장애인을 위해 제공 되며, 오디오로 웹에 전반적은 정보를 오디오로 제공한다 Head Part언어 인코딩&lt;meta charset=&quot;utf-8&quot;&gt; 태그 위에 선언해야 적용이 된다. charset (인코딩 설정) 해당문서가 어떤 언어로 인코딩 되었는지 알려준다. utf-8은 HTML5 방식으로 표기하는 방법이다. 통상 설정을 하지 않아도 작동이 되지만, 미 설정시 언어 글자가 깨져서 나오는 경우가 많다. html 언어 설정&lt;html lang=&quot;ko-KR&quot;&gt; &lt;/html&gt; 웹 접근성을 지침으로 안에 페이지의 기본 언어를 선언한다. Screen Reader 프로그램이 언어를 인식하여 자동으로 음성을 변환하거나 해당 언어에 적합한 발음을 제공한다. 시각장애인을 위한 보조 속성으로 command + f5를 누르면 실행된다. Ko을 사용하는 경우 영어를 기본적으로 제공 하지만, En은 한글 자동 변환을 지원하지 않는다. [selector] id스타일을 지정할 때 한 가지만 지정해서 사용한다. ( # selector)하나의 문서에 고유한 id 하나밖에 쓸 수 없다. class룹으로 묶어서 스타일을 지정할 때 사용한다. ( . selector) = id / class는 숫자로 시작해서는 안된다. [Multi selector] 자식 selector: [ &gt; ]~안에의 의미로 &gt; 만 사용이 가능하며 왼쪽이 부모 혹은 더 큰 selector을 넣는다.Ex) div &gt; p (div 안에 P만 선택) 후손 tag: [ space ]~안에 있는 A 모두를 선택 할 때 사용한다.Ex) div p (div 안에 P모두 선택) 그룹selector: , 다수에 selector에 공통된 스타일을 주고 싶을 경우 사용한다.Ex) div, p, a (div, p, a 모두) 특정 id 값: [ selector.id ]~안에 A 특정 태그 선택.Ex) p.foo (p태그 안에 id=”foo”을 가진 요소 선택) [Web page 설계 방식]3단 구조: header, body(content), footer4단 구조: header, navigation ,body(content), footer 1.선형화 단계화면 구성 나누기 2.시멘틱 요소그룹화 하기 3.Naming파스칼 첫 대문자카멜 첫 소문자 두번째 대문자 a. aside = 부가 정보b. article = 독립적인 , section = 콘텐츠 블록 Markup","link":"/2019/04/10/TIL-190410-html-markup-설계하기/"},{"title":"TIL-190411","text":"7일차(0411) - HTML/CSSHTML/CSS - What I learn… # article figure img alt , transition","link":"/2019/04/11/TIL-190411/"},{"title":"TIL-190412","text":"8일차(0412) - HTML/CSSHTML/CSS - What I learn… # ol q footer - article 내부에도 사용 가능 :hover 특징 counter() - counter(name, style) - name: 카운터 이름 - style: 기본값(생략)은 십진수(decimal), list-style-type과 동일한 값 * disc, circle, square, decimal, decimal-leading-zero, lower-roman, upper-roman, lower-greek, lower-latin, upper-latin, armenian, georgian, lower-alpha, upper-alpha, or none.","link":"/2019/04/12/TIL-190412/"},{"title":"TIL-190415","text":"9일차(0415) - HTML/CSSHTML/CSS - What I learn… # &lt;a href=&quot;mailto:code.ameba@gmail.com&quot;&gt;code.ameba@gmail.com&lt;/a&gt; 클릭 시 메일 작성 창 열림 `&lt;a href=“tel:01026840242”&gt;Tel-&gt; 모바일 환경에서 전화걸기 링크 &lt;header&gt;와 &lt;footer&gt;는 어디에나 들어갈 수 있다.(메인, 아티클, 섹션 등등) 푸터는 제목이 필요 없다 푸터의 주소에는 &lt;address&gt; 태그 사용 &lt;small&gt;: 주변 글자보다 작게 &lt;big&gt;: 주변 글자보다 크게 &amp;copy; 저작권 표시 반응형 웹 마크업이 심플해야 함 RWD(반응형) vs AWD(적응형) Flexible web design 다양한 패턴이 존재 desk top first vs mobile first 디바이스의 성능저하 고려해야 함 px 단위는 지양, %, vh 등의 비율 단위 지향 media queries @ : 앳사인 프린트용 CSS 별도 제작 및 연결 가능 모바일 세로 모드: 포트레이트 / 가로 모드: 랜드스케이프 sass(css 전처리기) 최근에는 scss를 더 많이 쓰는 편 img {max-width: 100%;height: auto;}` 모바일 환경에 맞는 아트디렉션 필요(단순히 사이즈를 줄이는 게 아닌 적절한 크롭) &lt;img src=&quot;#&quot; srcset=&quot;&quot;&gt; , &lt;picture&gt;, &lt;source&gt; 디바이스에 따른 조정 가능 @media screen device-pixel-ratio html shiv break point : 반응형에서 너비가 바뀌는 지점? padding 백분율은 가로 사이즈 기준.","link":"/2019/04/15/TIL-190415/"},{"title":"TIL-190416","text":"10일차(0416) - HTML/CSSHTML/CSS - What I learn… # picture, srcset 등으로 기기별 적절한 이미지 사이즈 적용 가능 반응형 배경이미지 https://webdir.tistory.com/81https://keycode.info/","link":"/2019/04/16/TIL-190416/"},{"title":"TIL-190417","text":"1일차 (0417) - 컴퓨터 공학Python - What I learn… # 파이선 언어란? 자료구조 / 알고리즘 Recursion 재귀Binary searchIndexSortStackHeap (segmentation) call by value call by reference 자바 스크립트는Single threaded =&gt; single call stackNon-blockingAsynchronousConcurrentCall stack / printSquare Function foo/ bar/ bez Blocking = 느리게 동작하는 코드 SetTimeout 32bit vs 64bit0, 1 = bit 차이점 와이어 갯수 메모리 주소값 정수 (integer)의 표현 일반적으로 1 바이트, 2바이트, 4바이트, 8바이트에 저장 부호 있는 정수(signed)와 부호 없는 정수(unsigned)로 나뉜다. 부호가 있는 경우 첫 bit가 부호를 나타냄(0: 양수, 1:음수)","link":"/2019/04/17/TIL-190417/"},{"title":"TIL-190419","text":"3일차 (0419) - 컴퓨터 공학Python - What I learn… # Jupyter Jupyter notebookNew =&gt; python3 A=10A=이름 객체 (변수) variable10=값 객체 파이선에는 box 모델이 적용 되지 않음 모든 것이 객체 언어 추상화어셈블리어 = 하드웨어 의존적 = low levelC/ C++ = 메모리를 직접 할당, 해제 = unmanaged languageJava/ C# = 언어 자체가 메모리를 할당 해제 =&gt; 가비지 컬랙션Python/ javascript = 자료형에 자유로워짐 = high level language =&gt; 생산성이 좋다 부동 소수점 (floating point)고정 소수점 (fixed point) mutable object(변수 가능객체) 리스트 딕셔너리 집합immutable object(변경불가능객체) 정수, 상수 문자열 튜플","link":"/2019/04/19/TIL-190419/"},{"title":"TIL-190418","text":"2일차 (0418) - 컴퓨터 공학Python - What I learn… # 프로그래머는 함수를 통해서 추상적인 함수 (function routine procedural, sub-routine)Procedural -programming = 절차 지향 객체(object) =&gt; OOP (object oriented programming) 객체지향 함수 (function)=&gt; function signature or interface함수 이름, 매개변수, 결과값(반환) =&gt; 내부 구현 (implantation) Function name = 함수가 어떤 일을 하는지 명확하게 나타낸다. 매개 변수, returna. 기능 명세 = 어떤 구조, 어떤 기술, 방식으로 설계할지 설계 (인터페이스 설계) Mantissa 52bit 는 정밀도를 말한다. 52 bit가 넘으면 에러로 정수로 떨어지지 않는다. Command =&gt; sys.float_info.mant_dig5353이 나오는 이유는 1.000000…앞에 1이 무조건 적으로 등장하기 때문에 1일 생략하여 mantissa에 52bit 에서 1bit를 초과하여 보여준다.","link":"/2019/04/18/TIL-190418/"},{"title":"TIL-190424","text":"6일차 (0424) - 컴퓨터 공학Python - What I learn… OOP Network Hanoi tower Sorting Quick sort OOP객체지향프로그래밍 OOP(Object Oriented Programming) 캡슐화 (encapsulation)하나의 객체가 특정한 목적을 가지고 필요한 변수나 메소드를 하나로 묶는 것을 의미한다.주된 목적으로 정보을 은닉화(information hiding) 하기 때문에 함수를 관련성 있게 클래스에 구성해야한다. 추상화 (Abstraction)공통된 속성이나 기능을 묶어 이름을 붙이는 것으로 객체 지향적 관점에서 클래스를 정의한는 행동이 추상적이라고 할 수 있다. 다형성 (Polymorphism)부모 클래스에서 물려받은 가상의 함수를 자식 클래스 안에서 메서드가 오버라이딩(method overriding)+함수 오버로딩 (function overloading) 되어 사용되는 것을 말한다. 상속된 객체를 확장, 변경을 간능하게 해주며, 이를 통해 코드를 재사용 및 코드 간결화 되어 코드 관리가 편하다. 상속성 (Inheritance)상위 특징을 하위가 물려받는 것으로 상위 클래스에 근거하여 새롭게 클래스 행위를 정의 할 수 있게 도와준다. 즉 상위 클래스에 기능을 재사용할 수 있지만 새로운 기능을 추가할 수 있다. 디자이 패턴 (solid) S – single responsibility principle (단일 책임) O – open-closed principle (확장 폐쇠) L – liskov substitution principle (리스트프 치환) I – interface segregation principle (인터페이스 분리) D – Depending intorsion principle (의존 역전) Hanoi gamedef hanoi(n, _from, _by, _to):Base Caseㄴif n==1:print(f’{n}번쨰 쟁반을 {_from}에서 {_to}로 이동’)return hanoi(n-1, _from, _to, _by)print(f’{n}번쨰 쟁반을 {_from}에서 {_to}로 이동’)hanoi(n-1, _by, _from, _to) = hanoi(n, “A”, “B”, “C”) 버블 정렬데이터 갯 수If 4 = 3+2+1If 6 = 5+4+3+2+1  For,while 문을 사용하지 않고 1~n에 수를 모두 더하기[재귀함수 방식]def sumation(n):if n==1:return 1return sumation(n-1)+n [등차 수열 방식]def sumation(n):return n*(1+n)//2 절차지향 함수= 함수 시그니처 // 기능, 구현 객체지향 객체(object) /= (관련있는) +변수 상태정보(데이터) / 특성값 +함수 (메서드) 기능 ( input + 상태 정보(맴버) -&gt; output NetworkOSI 7 계층 응용 계층 (Application Layer) 표현 계층 (Presentation Layer) 세션 계층 (Session Layer) 전송 계층 (Transport Layer) 네트워크 계층 (Network Layer) 데이터 링크 계층 (Data link Layer) 물리 계층 (Physical Layer) LAN : local area Network WAN: Wide area Network Packet(패킷) = 보내는 사람, 받는 사람 Arp =Ip =&gt; mac Arp 스쿱핑 = 맥어드래스를 가로채어 정보를 빼오는 방식 Ip protocol Subnet mask: ICT: internet service providerHost ID에 할당된 비트를 잘라서 서브넷으로 Public IP : 세계적으로 Unique하다 Private IP DHCP : dynamic host configuration protocol Sorting단순 알고리즘Bubble sortInsertion sortSelection sort분할 알고리즘Quick sortMerge sortHeap sort 분할 정복 기법 (divide &amp; conquer)어려운 문제를 잘게 나누어서 하나씩 해결작은 Solution이 모여서 전체(큰)문제를 해결 Quick sortdef quick_sort(li, start, end): #base case #todoif start &gt;= end:return left = startright = endpivot = li [(left+right)//2] #left와 right가 교차하기 전까지while left &lt;= right: #list[left]가 피벗 보다 크면while li[left] &lt; pivot:left+=1 #list[right]가 피벗 보다 작으면while li[right] &gt; pivot:right-=1 if left &lt;= right:li[left], li[right]=li[right], li[left]left+=1right-=1 quick_sort(li, start, right)quick_sort(li, left, end) test codeimport randomwhile True:numdata=int(input(‘데이터 개수(종료:0):’))if not num_data:breakdata=[random.randint(1, 100) for in range(num_data)]print(data)quick_sort(data, 0, len(data)-1)print(data)","link":"/2019/04/24/TIL-190424/"},{"title":"TIL-190422","text":"4일차 (0422) - 컴퓨터 공학Python - What I learn… Call by object reference Call by reference Call by value 함수란? 어떤 입력에 대한 작업의 결과를 출력해 주는 것 함수를 사용하는 이유 반복되는 내용을 효율적으로 처리하기 위함 코드를 효율적으로 만들고 추가적으로 가독성도 올라가기 때문에 Name space소속을 나타내는 역할을 합니다. 즉 변수 이름이나 함수 이름과 같이 명칭을 사용하는 공간에 의미로 변수가 저장되어 있는 공간. [namespace]::[변수 혹은 함수] 그러나 네임스페이스는 소속 공간에 따라서 변수나 함수가 같은 이름임에도 다른 식으로 구분이 될 수 있다.ㄴ Stack frame이름 객체에 쌓이는 func frame메모리 공간 함수를 실행할 때 인자(parameter)를 어떻게 전달할 것인가?Call by value // stack frame이 분리되어져 있어 바깥으로 값을 뺄 수 없다Call by reference // stack frame 바깥으로 주소 값을 접근 및 수정이 가능하다. Immutable object =&gt; 함수 내부에서 값을 변경할 수 없다.Mutable object =&gt; 새로운 객체를 할당하는 것이 아니라면 함수 내부에서 값을 변경할 수 있다 Call by object reference함수 내부에서 튜플 값을 바꿔야 한다면tu = (1,2,3)def change_tu(tu, e1, e2, e3):tu=(e1,e2,e3)print(tu, ‘in change_tu’)return tu tu=change_tu(tu,4,5,6)print(tu) Nonlocalfirst function class 1. 함수를 인자(argument)로 전달def f(func, a, b): return func(a,b) def g(a,b): return a+b a=10 b=20f(g,a,b)output =30 2. 함수를 리턴(return) 값으로 전달def calc(kind): if kind==&quot;add&quot;: def add(a,b): return a+b return add elif kind==&quot;sub&quot;: def sub(a,b): return a-b return sub adder=calc(‘add’)adder (10,20)output = 30 3. 함수를 변수에 전달함수를 다른 함수의 전달 인자 로 사용하고, 함수에서 함수를 리턴 하거나 변수의 값으로 함수를 할당 가능 익명 함수(lambda)def func(a,b)return a+bf=lambda a, b: a+b //람다는 반드시 리턴한다. Javascript lambda =Function( ){} 함수 =&gt; lazy evaluation = 내가 필요할 때Map (func, iterable) // 사상 맵핑을 한다Filter (Reduce 리스트에 모든 값을 더한다. (reduce(lambda a, b: a+b, li)) List comprehension 삼항연산자A=10If a &gt; 7:String=“big”ElseString=”smaill” String “big” If a &gt; 7 else “smaill” // 참일 때 값 if 조건문 else 거짓일때 값 Dic.get[“e”] // 값이 없으면 noneDic [“e”] // 값이 없으면 에러Dic.update Closure함수 내부에 상태 정보를 저장해 두고 함수 결과가 이 내부의 상태 정보에 따라 출력 값이 달라진다.OOP를 쓸 수 없을떄 로컬 변수 함수가 실행 도중에 데이터를 저장하기 위해서 상태 정보: 특정한 데이터의 현제 상태문법: 계좌 클로져 함수:Def account(cus_name, balance):Def inner (money):Balance += moneyReturn cus_name, balanceReturn innerMy_acnt=account(‘greg. 5000)Your_acnt = account (“john”, 300) Linear search (선형 탐색)N -&gt; t(n) = n Binary search타겟을 찾았다면 인덱스 반환/ 찾지 못하면 noneN -&gt; t(n)= log^2n","link":"/2019/04/22/TIL-190422/"},{"title":"TIL-190426","text":"7일차 (0426) - 컴퓨터 공학Python - What I learn… 자료구조 Queue ADT (abstract data type) 추상 자료형 구체적인 구현 설명을 언급하지 않는, 순수하게 기능을 나열한 것을 말한다. 자료구조(연결리스트, 스택, 큐 등) 의 인터페이스(함수 시그니처),오퍼레이션을 명시해 놓은 것이다.= 자료구조의 함수 사용법을 나타냄. 배열 연결구조 (어뎁터) 파이썬의 리스트 S.empty() -&gt; Boolean스택이 비어있으면 true, 아니면 falses S.push(data) -&gt; None스택이 맨 위에 데이터를 쌓는다 S.pop() -&gt; data스택 맨 위의 데이터를 삭제하면서 반환 S.peek() -&gt; data스택 맨 위 데이터를 반환 Queue 큐 \\ (Q &gt; 자료구조)FIFO(First-In-First-Out) 방식으로 스택과 반대로 먼저 저장된 값이 제일 먼저 나온다. 즉 가장 최근에 저장된 값은 가장 먼저 나오게된다.EX) 1,2,3 -&gt; 3,2,1 Q.empty() -&gt; Boolean - 큐가 비어 있을 때에 true를, 아니면 false 반환한다. Q.enqueue -&gt; None - 큐의 맨 뒤에 데이터를 쌓는다. Q.dequeue -&gt; data - 큐 맨 앞의 데이터를 삭제하면서 반환 Q.peek -&gt; data - 큐에서 가장 위(앞)에 있는 데이터을 반환한다. add(item): item을 리스트의 끝부분에 추가한다. remove(): 리스트의 첫 번째 항목을 제거한다. Linked list 연결 리스트노드를 단위를 한다. 노드는 데이터와 다음 노드를 가리키는 참조값으로 구성되어 있다. Sigle linked list= 이전 데이터로 접근을 할 수 없다. Operations S.empty() -&gt; Boolean - 리스트가 비었다면 true, 아니면 false S.size() -&gt; None - 리스트에 있는 요소 개수 S.add() -&gt; None - 노드를 리스트의 맨 앞에 추가 S.search(target) -&gt; Node - 리스트에서 target을 찾는다 - 찾으면 노드를, 못 찾으면 None 반환 S.delete() -&gt; None - 맨 앞 노드를 삭제 Double linked list = Dummy double linked list (이중 연결 리스트) = 데이터를 가지지 않은 노드 = 구현 편의성이 높아진다. Operations구조 Head – 리스트 맨 앞에 있는 더미 Tail – 리스트 맨 뒤에 있는 더미를 가리킨다. d-size – 리스트의 요소 개수 Operations S.empty() -&gt; Boolean -리스트가 비었다면 True,아니면 False S.size() -&gt; integer -리스트에 있는 요소 개수 Insert 계열 공부 리스트순회 (traversal) 배열1|2|3|4|5|6 장점) 검색이 빠르다 -&gt; 인덱싱O(1) 단점) Insert =&gt; delete O(n) 연결리스트1-2-3-4-5-6 장점) 검색이 느리다O(n) 단점) Insert =&gt; delete O(1) 성형 자료구조Linked listStackQueue비선형 자료구조Tree 순회(traversal)a. 전위 (preorder)b. 중위 (in order)c. 후위 (post order)a,b,c, = stack =&gt; DESd. 레벨순서 (level order) BST (binary search tree)O(n^2) -&gt; search 균형 이진 트리(balanced, self balanced)a. AVL. 트리b. RED-black 트리 B-tree (데이터베이스 인덱스)균형 이진트리+ …아키텍쳐 Heap (완전 이진트리, 배열) Hash tree (map) Hash function collision (충돌)a. chaining (체이닝)b. open – addressing 기법 graph (그래프) 순회 (travelsal)a. DFS – 깊이를 우선 탐색 -&gt; 스택b. BFS – 너비 우선 탐색 -&gt; Queue MST(최소 신장 트리)Minimum spanning tree-&gt;greedy algorithm-krusskal algorithm-prim algorithm 최단경로 문제(shortist path) Dijksta algorithm-greedy algorithm 2. bellmam-ford algorithm 3. flord-warshall algorithm-dynamic programming","link":"/2019/04/26/TIL-190426/"},{"title":"TIL-190425","text":"7일차 (0425) - 컴퓨터 공학Python - What I learn… Network TCP/IP 알고리즘 NetworkWAN PortWide Area Network - Local Network들을 통신하게 해주는 네트워크로 자신을 포함하지 않는 큰 범위에 네트워크. LAN portLocal Area Network 지역 네트워크로 이더넷 프로토콜을 사용하며 자신을 포함한 작은 네트워크 단위를 구성하는 네크워크망. IPPublic IP (공인 IP 주소)Globally Unique IP Private IP (사설 IP 주소)Private Network 상에 존재하며 NAT를 통해 인터넷에 연결이 가능하다. 하지만 인테닛 상에서 Private IP address로 연결이 불가능하다. IP routing table라우터가 경로를 찾을 때 사용하는 것으로, 패킷을 전송할 때 인터페이스의 데이터 링크 프레임 안에 IP 패킷을 캡슐화된 네트워크에 대한 정보를 포함하고 있다. Applicationhttp =메세지 기반에 “문자열”https = SSL / TLS을 포함한 보안이 개선된 웹 통신 방식FTPSMTPDNS = domain name service사람이 읽기 쉽다DNS를 =&gt; IP로 바꾼다 Translate (전송) / port =&gt; 특정process에 저장 Internet / IP (ip routing) – ip address Network Interface / ethernet (mac address) Port (Translate section)socket에 부여된 주소 숫자로서 특정 프로세스로 데이터를 전달할 수 있다.(0~2^16-1 정수)Socket = listening socket / data socketClient 프로세스 TCP (Transmission Control Protocol) 연결 지향형 Protocol로서 신뢰도가 높다. 패킷이 유실 되면 일정 시간 후 데이터를 재전송 해준다. 네크워크에 부담을 준다. UDP (User Datagram Protocol) 비 연결 지향형 Protocol로서 신뢰도가 낮다. 패킷 전송후 데이터 일부가 손실 되어도 재전송을 하지 않는다. 통신 속도가 빠르다. HTTPURL =&gt; http:// user : password @ host : port/urlpath ?query # bookmark port = 기본적으로 80을 쓰므로 일반적으로 생략이 가능 HTML/1.0 = 일시적 연결 TCP 연결 후 하나의 요청/ 응답 후 연결을 끊는다. HTML/1.1 = 지속적인 연결 (persistent connection) TCP 연결을 그대로 유지한다. Connection: close 헤더를 포함해 일시적 연결을 끊는다. 효율적인 캐싱과 프록싱 컨텐트 협상 Error 메세지200번대: 성공 메세지 300번대400번대: Client 에러 500번대: server 에러 Comparison Sort 종류Quick sortRandom pivot 피벗이 1이나 왔을때 n^2이된다. 이를 막기 위해 피벗과 가장 왼쪽에 값을 교체한다 Big O -&gt; averageInsertion sort 삽입 정열 Selection sort 선택 정열 Merge sort연산 리스트배열과 연결 리스트스택, 큐Tree순회전위중위후위레벨순서","link":"/2019/04/25/TIL-190425/"},{"title":"TIL_190401","text":"1일차(0401) - HTML/CSSHTML/CSS - What I learn… html의 기본 구조 시맨틱 마크업 박스 모델 XMLXML은 Extensible Markup Language의 약자이며, W3C에서 개발된 표준 권고안 마크업 언어이다. XML은 데이터를 저장하고 전달할 목적으로만 만들어졌습니다. HTML과 다르게 미리 정의되어 있는 구조가 아닌, 사용자가 직접 정의해서 사용할 수 있습니다. HTML 4.01 vs HTML 5.0WHATWGWeb Hypertext Application Technology Working Group의 약자로 인터넷이 보급화 되면서, 무분별한 웹 형식과 액티브 X같은 플러그인으로 인해 웹 페이지가 무거워 졌습니다. 그래서 W3C에서 제안한 표준안으로 만들어진 그룹이다. HTML 기본 구조3단 Structure < html > < head > < /head > < body > (content) < /body > < footer > < /footer > < /html > 4단 Structure < html > < head > < /head > < nav > < /nav > < body > (content) < /body > < footer > < /footer > < /html > 선형화 단계 (Linearization Step)논리적으로 HTML을 구성하기 위해 마크업은 규칙에 따라 콘텐츠를 설계하는 단계이다. 선형화 단계를 거치면 전체적은 웹 페이지에 구성을 보기 쉽게 정리할 수 있고, CSS 작업시 좀더 간결한 작업을 할 수 있다. 시맨틱 요소 (Semantic Element)&lt; header &gt;&lt;div id=”header”&gt; &lt;header class=&quot;header&quot;&gt; header는 html 문서에 첫 머리말로 사용이 가능하여 여러번 사용이 가능하다. 즉 section, body 안에 header을 사용하여 구분을 짓기 위해 사용이 가능하다. &lt; footer &gt;&lt;div id=&quot;footer&quot;&gt; &lt;footer class=&quot;footer&quot;&gt; Webpage의 Copyright이나 회사 주소 정보를 사용 할 수 있다.section에 꼬리말로 사용하고 html 내에서 다수 사용이 가능하다. &lt; section &gt;&lt;div id=&quot;section&quot; class=&quot;section&quot;&gt;&lt;/div&gt; &lt;section id=&quot;#&quot; class=&quot;#&quot;&gt;&lt;/section&gt; 콘텐츠를 grouping 할 때 사용. Section 안에 section을 사용 할 수 있어서 중첩 사용이 가능하다. &lt; nav &gt;&lt;div id=&quot;nav&quot; class=&quot;nav&quot;&gt;&lt;/div&gt; &lt;nav id=&quot;#&quot; class=&quot;#&quot;&gt;&lt;/nav&gt; Navigation의 줄임말. navigation 메뉴를 나타낸다. 주로 헤딩 부분에 사용하지만, body 내부에 navigation 섹션에도 사용이 가능하다. &lt; article &gt;&lt;div id=&quot;article&quot; class=&quot;article&quot;&gt;&lt;/div&gt; &lt;article id=&quot;#&quot; class=&quot;#&quot;&gt;&lt;/article&gt; 독립적인 글들을 나타낼 때 사용. 블로그 포스팅 표현 할 때 사용하지만, RSS feed로 배포할 가치가 있는 컨텐츠에 사용한다. &lt; aside &gt;&lt;div id=&quot;aside&quot; class=&quot;aside&quot;&gt;&lt;/div&gt; &lt;aside id=&quot;#&quot; class=&quot;#&quot;&gt;&lt;/aside&gt; 콘텐츠와 관계 있는 부가 정보들을 표시 할 때 사용한다. 주로 side-bar콘텐츠들을 담기 위해 사용하기도 한다. &lt; main &gt;&lt;div id=&quot;main&quot; class=&quot;main&quot;&gt;&lt;/div&gt; &lt;main id=&quot;#&quot; class=&quot;#&quot;&gt;&lt;/main&gt; 주로 웹 페이지를 구성하는 메인 콘텐츠를 담는 태그이다. body 태그를 사용하여 구분할 수 있다. HTML 네이밍- [selector] id스타일을 지정할 때 한 가지만 지정해서 사용한다. ( # selector)하나의 문서에 고유한 id 하나밖에 쓸 수 없다. class그룹으로 묶어서 스타일을 지정할 때 사용한다. ( . selector) | id / class는 숫자로 시작해서는 안된다.| - [Naming convention] 식별자의 명칭이 되는 문자열에 방식을 결정하기 위한 규칙. 가독성, 시인성, 효울성에 목적을 가진다. 프로젝트, 프로그래밍 언어, 개발도구에 따라 방식을 결정한다. - [Coding Conventions] 프로그래밍 스타일에 관한 가이드 라인 모음. - [표기법] 카멜 표기법 / “camelCase” 각 단어의 첫문자는 대문자로 표기. 단 맨 처음 단어는 소문자로 시작.(띄어쓰기 대신 대문자로 구문함) 파스칼 표기법 / “PascalCase” 모든 단어의 첫문자를 대문자로 시작. 스네이크 표기법 / “snake_case” 단어를 밑줄문자로 구분하는 표기법 Perl, PHP, Python, Ruby, Rust 언어는 주로 스네이크 표기법을 사용한다. 헝가리언 표기법 / “strHungarian” 접두어를 사용하는 표기법 접두어 예시 b / 불리언 (boolean) ch / 문자 (char) f / float sz / NULL로 끝나는 문자열 (string+zero) WAI-ARIA정의Web Accessibility Initiative-Accessible Rich Internet Applications.WAI-ARIA는 접근성 및 상호 운용성을 향상시키기 위해 마크업에 역할 (Role), 속성 (Property), 상태 (State) 추가하여 스크린리더 및 음성지원 보조기기 사용을 용이하게 해준다. CSS - Box model박스 앨리먼트의 hight와 width로 사각형 박스 모양을 가지고 있다. 박스 모델은 마진(margin), 패딩(padding), 보더(border)로 구성되어 있다. normal flow일반적인 상황에서 각각의 요소들이 배치되는 순서를 뜻하는 말로서 기본 페이지 레이아웃에서 블록요소들은 기본적으로 상하 배치된다. flexfloatclearPseudo-Element(가상요소)::before, ::after, :hover","link":"/2019/04/01/TIL-190401/"},{"title":"TIL-190502","text":"4일차 (0502) - JavascriptJavascript - What I learn… 연산자 1. 표현식과 연산자표현식 (expression)은 리터럴, 식별자(변수명, 함수명 등), 연산자, 함수 등 토큰(Token)의 조합을 말한다. 즉 표현식은 하나의 값으로 평가(evaluation) 될 수 있는 문을 말한다.표현식은 결국 하나의 값이 되므로 표현식은 값으로 사용할 수 있다. 즉 값에 위치에 표현식을 위치할 수 있다. var x = 10; // 표현식 x + 30은 식별자 표현식과 숫자 리터럴과 연산자의 조합으로 구성되어 있다. console.log(x + 30); // 40 표현식은 표현식을 결합해 새로운 값을 만들어 내는것이 가장 일반적이다. 2. 문과 표현식문(statement)은 하나 이상의 표현식과 키워드의 조합으로 구성된 자바스크립트 엔진에게 내리는 명령이다. 문이 실행이 된다는 것을 명령이 시작되고, 문의 집합을 순서에 맞게 나열한 것을 프로그램이라고 부른다. 자바스크립트의 모든 코드는 문 또는 표현식이다. 표현식의 역할은 값을 생성하는 것이다. 문의 역할은 표현식으로 생성한 값을 자바스크립트에 명령(문에 대표적 특징)을 내리는 것이다. 문은 구성 뒤에 세미콜른(;)으로 끝나며, 단 코드 블록{…}뒤에는 세미콜론을 붙이지 않는다. 세미콜론 자동 삽입 기능(ASI, automatic semicolon insertion)문의 끝에는 세미콜론을 옵션으로 본다. 자바스크립트 엔진에는 세미콜론을 자동으로 붙여주지만, 개발자의 예측과 의도에 다른 경우도 간혹 있다. 3. 표현식인 문과 표현식이 아닌 문표현식은 값이 평가될 수 있는지 없는지에 따라 결정된다. 즉 선언문은 표현식이될 수 없지만, 할당문은 값을 평가할 수 있으므로 자체적으로 표현문에 의미가 성립한다. 표현문이 맞는지 의문이 든다면, 변수에 할당해 보는 것이다. 즉 표현문은 값을 나타내므로 변수에 할당이 가능하다. // 변수 선언문은 표현식이 아닌 문이다. var x ; // 할당문 자체가 표현식이지만 완전한 문이기도 하다. 즉, 할당문은 표현식인 문이다. x = 100; // 표현식이 아닌 문은 값처럼 사용할 수 없다.(할당문) var foo = var x; // SyntaxError: Unexpected token var 할당문 자체를 값으로 사용이 가능하다. 완료 값 (Completion value)크롬 개발자 도구는 표현식이 아닌 문은 언제나 undefined를 출력한다. 완료 값은 변수에 할당할 수 없다. 4. 연산자(Operator)란?하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입 연산(operation)등을 수행해 하나의 값을 만든다. 연산의 대상을 피연산자(Operand)라 하며, 피연산자도 평가가 가능하다. 5. 산술 연산자(Arithmetic Operator)란?수학적 계산으로 새로운 숫자값을 만드며, 산술 연산이 불가능한 경우 NaN을 반환한다. (산술 연산자와 피연산자의 개수에 따라 이항 산술 연산자와 단항 산술 연산자로 구분한다.) 5.1. 이항 산술 연산자2개의 피연산자를 산술한다. 이항 연산자는 피연산자의 값을 변경하는 부수 효과(side effect)가 없다. 즉 항상 새로운 값을 만들어 낸다. 5.2. 단항(Unary) 산술 연산자1개의 피연산자를 산술한다. 단항 연산자는 증가/감소(++/–)로 피연산자의 값을 변경하는 부수 효과가 있다. 위치에 따라 의미가 달라진다 전위 증가/감소(Prefix increment / decrement operator) 피연산자의 값을 증가 / 감소 시킨후, 다른 연산을 수행. 후위 증가/감소(Postfix increment / decrement operator) 먼저 다른 연산 실행 후 피연산자의 값을 증가 / 감소. 5.3. 문자열 연결 연산자6. 할당 연산자7. 비교 연산자7.1. 동등 / 일치 비교 연산자7.2 대소 관계 비교 연산자8. 삼항 조건 연산자9. 논리 연산자10. 쉼표 연산자11. 그룹 연산자12. Typeof 연산자함수가 아니라 연산자로서 타입을 알고 싶은 표현식(값으로 평가될 수 있는)이 와야 한다.","link":"/2019/05/02/TIL-190502/"},{"title":"TIL-190423","text":"5일차 (0423) - 컴퓨터 공학Python - What I learn… 이진 탐색. big O Process vs thread Recursion 재귀 [Binary search] 이진 탐색이진 검색은 정렬된 리스트에서 원하는 항목을 찾기에 효율적인 알고리즘 입니다. 리스트를 반으로 나누고 타겟 값이 나올 때까지 항목을 좁혀갑니다.선형 검색(linear search)는 모든 항목을 하나씩 검사해야 하는 문제가 있어 항목이 많다면 이진 탐색이 적절합니다. [이진 탐색 절차] Low = 0, high = n-1 로 초기화 Mid는 (low + high)을 2로 나눈 몫으로 결정합니다. Data[mid]와 target이 서로 같으면 탐색 종료 만약 target &lt; data[mid]이면 high = mid-1로 업데이트 한 후, 2회 돌아갑니다 [Segmentation]가상 메모리를 관리하는 기법으로 가상 메모리에 로드된 프로세스가 가상에 공간에 물리 메모리를 갖고 있는 것처럼 사용할 수 있다. 가상 메모리는 각 프로세스당 메인 메모리와 동일한 크기로 할당되며, 프로세스의 일부만 메모리에 로드하고 나머지를 보조 장치에 로드하는 형식으로 작동 된다. – Segmentation 기법이란메모리를 논리적 내용의 단위로 잘라 분할된 메모리를 할당하여 물리 주소로 부터 블록 단위로 변환하는 것을 말한다. – Paging 기법Segmentation과 가상 메모리를 고정된 크기로 나누어 메모리를 관리하는 기법이다. 즉 큰 용량에 작업을 작게 쪼개어 처리하는 방식으로 불연속적인 메모리 요청 등에 유연하게 처리할 수 있다. Segmentation 과 다르게 고정된 크기로 할당하는 방식으로 차이점을 보인다. – page frame페이지(고정된 크기의 블록)를 물리 메모리와 같은 크기로 나누어진 블록 단위. 물리 메모리를 사용하는 최소 크기 단위 – page fault가상 메모리 주소를 할당하는 방식으로 RAM의 부족한 용량을 보완하는데 사용한다. 가상 메모리를 사용하는 최소 크기 단위 구조 Code Data Heap Stack Cache메모리 계층 중 하나로 속도가 빠른 장치와 느린 창치간의 속도차에 따른 병목 현상을 줄이기 위한 범용 메모리. 데이터 지역성(locality)의 원리를 사용한다. – Cache hit적중율의 극대화로 Cache Access 시간 최소화 – Cache miss실패율에 따른 지연시간(Miss Penalty) 최소화 Big - o알고리즘에 효율성을 나타내는 지표로서 내가 개선한 알고리즘에 효율성, 연산 속도를 비교하기 위해 사용합니다. O(1) 상수 시간 (속도가 빠르다) / =&gt; arr [0] / linked-list insert, delete O(log n) 로그 시간 / =&gt; BST O(n) 선형 시간 / =&gt; linked-list search 배열 삽입, 삭제 O(n log n) 선형 로그 시간 / =&gt; quick sort, merge sorta. Comparism sorting (비교 정렬) O(n^2) 지수 시간 / 버블 sort, 선택 정렬, 삽입 정렬 Compiler vs interpreter Process =&gt;OSa. Job scheduling and scheduleri. Context switchingb. Process statusi. Tread =&gt; multithreading Concurrency programming (동시성 프로그래밍)a. Multi-threading =&gt; CPU (bound) 작업이 많을 떄 사용i. Race-conditionii. Dead-lockb. Asynchronous I/O (I/O bound) Multi-threading 메모리, 성능에 매우 우월함 Race condition Program(image) 하드 디스크에 저장되어 있는 “하나”의 이미지(code/data) Process 메인 메모리에 올라와서 실행을 시작한 프로그램 PID (process ID) 선정형 스케줄러 : preemptive scheduling (Preemption) =&gt; multi-tasking 가능 비선정형 스케줄러: non- preemptive scheduling Process status (infographic) 알고리즘 구성 • Priority algorithm• Round-robin algorithmo 정해진 시간 동안 실행 Time slice QuantumI/O 작업 =&gt; 네트워크속도가 느리지만 CPU가 필요 없다 Thread =&gt;Context-switching =&gt;CPU에 저장 되어있는 레지스터 값을 PCB 레지스터에서 교체 되는 행위 = 라운드 로빈에서 타임 슬라이스가 지날 때마다 일어난다Instruction Register (IR)현재 실행되고 있는Program counter (PC) PCB Process vs thread실행 흐름 – Instruction인스트럭션(기계어)에 나열 VAS = visual address space 가상 주소 공간 GIL = global interpreter lock Parallel programming /하드웨어가 다수 필요함 Concurrency programming한개의 하드웨어로 Single core multithreading Multi core multithreading Multithreading =&gt; 공유 자원이 필요하다Race condition이 발생함: 한정된 자원을 여러 개의 프로세스다 동시에 이용이 될 때 프로세스가 자원 이용을 위해 경쟁을 벌이는 현상 Critical Section임계영역어떤 스레드에서 공유 자원에 접근한 후수정, 변경 하려는 코드$ lock=threading.Lock() $ lock.release()Recursion 재귀 함수 호출 도중에 자기 자신을 다시 호출하는 것 Base case (기저 조건)재귀 호출에 빠지거나, 재귀 호출을 일으키지 않는 함수의 기본 케이스 이다. Terminal case (종료 조건, 탈출 조건)\\$ def func(n):// Print (n) =&gt; I/O작업 #base caseIf n &lt;= 0;ReturnFunc(n-1) 재귀함수 만드는법 패턴을 찾는다  점화식을 만든다 기저 조건을 만든다 Factorial (계승)3! = 321 3!= 32! 2!=21! 5! = 5*4*3*2*1 점화식 Fac(n) = fac(n-1)*n 기저 조건 n==1 or n==0 return 1 test) def factorial (n):if n==0 or n==1:return 1return factorial (n-1) *nfor i in range (1,6):print (factorial(i))fibonacci series피보나치점화식fibo(n) = fibo(n-2) + fibo (n-1)기저 조건if n==1 then 0If n==2 then 1 Def fibo(n): If n==1: Return 0 elIf n==2: Return 1 Return fibo(n-2) + fibo(n-1) For i in range (1, 11): Print (fibo(i), end=’ ’)","link":"/2019/04/23/TIL-190423/"},{"title":"TIL-190505","text":"7일차 (0505) - JavascriptJavascript - What I learn… 객체 리터럴 객체 리터럴1. 객체란자바스크립트는 객체 지향 프로그래밍 언어이다. 즉 자바스크립트는 원시 값 제외한 나머지(함수, 배열, 정규표현식 등) 값들은 모두이 객체이다. 원시 타입은 단 하나의 값만 가지며, 2. 객체 리터럴 의한 객체 생성3. 프로퍼티4. 메소드5. 프로퍼티 접근6. 프로퍼티 값 갱신7. 프로퍼티 동적 생성존재하지 않는 프로퍼티 값을 할당하면 프로퍼티가 동적으로 값을 추가한다. 이때 프로퍼티는 자유롭게 추가, 제거할 수 있다. 1234var item = { name: \"pen\"};item.count = \"two\"; 8. 프로퍼티 삭제9. ES6에서 추가된 객체 리터럴의 확장 기능9.1 프로퍼티 축약 표현9.2 프로퍼티 키 동적 생성9.3 메소드 축약 표현","link":"/2019/05/05/TIL-190505/"},{"title":"TIL-190506","text":"8일차 (0506) - JavascriptJavascript - What I learn… 원시 값과 객체의 비교 원시 값과 객체의 비교1. 원시 값자바스크립트는 7가지의 원시 타입(Primitive type) 과 객체 타입(Object/Reference type)으로 구분할 수 있다. 자바스크립트는 객체 타입언어로 원시적 타입은 중요한 의미를 지닌다. 원시 타입은 값은 변경 불가능한 값(immutable value)으로 객체 타입(mutable value)에 비해 제안 사항이 많다. 변수 할당시 원시값은 실제 값이 저장되고, 객체는 참조 값이 저장된다. 원시 값에 전달 (pass by value)로서 원시 값이 복사 전달, 객체 값은 원본의 참조값이 복사되는 (pass by reference)라 한다. 1.1 변경 불가능한 값 (immutable value)한번 생성된 값은 read only로 값을 변경이 불가능한 값 원시 타입(primitive type), 즉 immutable value라고 한다.값을 변경할 수 없다는 것은 재할당의 의미가 아니다. 상수는 단 한번만 할당이 가능한 변수이다. 그러나 상수도 메모리에 공간을 사용하는 일종에 변수이지만, 변경이 불가능한 값이라고 할 수는 없다. 원시 값‘foo’, true, false, null, undefined 원시 값은 어떤 일이 있어도 불변한다. 즉 이 값은 신뢰성이 확보가 된다.원시 값은 재할당 될때 새로운 메모리 공간을 재할당하고 할당된 새 주소를 가르킨다. 이를 불변성(immutability)이라고 한다. 1.2 문자열과 불변성1.3 값에 의한 전달2. 객체객체는 프로퍼티를 동적으로 추가, 삭제할 수 있다. 또한 값에 제한이 없기 때문에 확보해야 할 메모리를 예측할 수 없다. 자바스크립트의 객체 관리 방식 2.1 변경 가능한 값 얇은 복사 = 참조값을 복사 (링크)딥 카피 = 객체 자체를 복사 (원본=내용) 2.2 참조에 의한 전달두개 이상에 식별자가 하나의 객체를 공유할 수 있다. 1234567891011121314// var은 재 할당이 언제든지 가능하다.var a = 10;a = 20;var = 20;// let은 let을 사용해서 재할당이 불가능하다.let b = 10;b = 20; // 재할당 가능let b = 20; // Uncaught SyntaxError// const는 무조건 1번한 할당 가능const c = 10;c = 10; // Uncaught TypeErrorconst c = 20; // Uncaught SyntaxError","link":"/2019/05/06/TIL-190506/"},{"title":"TIL-190508","text":"10일차 (0508) - JavascriptJavascript - What I learn… 스코프 스코프1. 스코프란?식별자를 관리하는 기능. 자료구조 형태에 식별자와 값을 묶어 놓은 레이어 환경. 함수내부에서 생성한 변수는 지역 변수 = 그 지역 안에서만 적용이된다. 상위 스코프에서 하위스코프를 사용이 불가능하지만, 하위 스코프는 상위 스코프를 사용할 수 있다. = 선언 위치사 중요하다. 2. 스코프의 종류 구분 설명 스코프 변수 전역 코드의 가장 바깥 영역 전역 스코프 전역변수 2.1 전역과 전역 스코프2.2 지역과 지역 스코프3. 스코프 체인스코프가 중첩되면서 상하 관계를 갖는것 4. 스코프 체인에 의한 변수 검색5. 스코프 체인에 의한 함수 검색6. 함수 레벨 스코프7. 렉시컬 스코프함수가 생성될때 내부 스코프가 상위 스코프를 포함할지 결정하는 것이 렉시컬 이다.변수가 선언되는 위치가 중요하다. 상위 스코프가 무엇인지에 따라 결정된다. 8. 암묵적 전역 변수","link":"/2019/05/08/TIL-190508/"},{"title":"TIL-190509","text":"11일차 (0509) - JavascriptJavascript - What I learn… 전역 변수의 문제점 전역 변수의 문제점1. 변수의 생명 주기전역 변수보다 지역 변수를 사용하여 변수의 생명 주기를 짧게 해야한다. 또한 변수의 생명 주기가 길면 메모리를 더 많이 점유하게 된다. 변수 호이스팅전역변수 호이스팅, 지역변수 호이스팅으로 스코프 단위로 동작한다. 호이스팅은 변수 선언이 스코프에 선두로 끌어 올려진 것처럼 동작한다. 1.1 지역 변수의 생명 주기지역 변수, 즉 함수 내부에서 선언된 변수의 생명 주기는 함수가 종료되면 소멸한다. 1234567function foo() { var x = \"local\"; console.log(x); // =&gt; local return x;}foo();console.log(x); // =&gt; ReferenceError x is not defined 함수는 호출되기 이전까지 생성되지 않는다. 이때 변수 x의 선언문이 자바스크립트 엔진에 먼저 실행되어 변수 x가 선언되고, x는 undefined로 초기화 된다. foo함수가 실행 될때 x값이 할당되고 이 값는 foo함수 내에서만 존재하고, 삭제된다. 1.2 전역 변수의 생명 주기전역 변수의 생명 주기는 애플리케이션의 생명 주기와 같아서 프로그램이 종료 되면 소멸한다. 지역 변수와 달리 호출없이 실행된다. 즉 entry point 없이 코드 로드후 바로 해석된다. 진입점 (entry point)C, java로 작성된 코드를 실행하면 가장 먼저 main 함수가 호출 되는데, 이를 진입점 혹은 시작점이라고 부른다. return 문return 문은 실행되면 문이 종료가 된다, 즉 함수 몸체 마지막에 사용한다. 123456789var x = \"global\";function foo() { console.log(x); // =&gt; global var x = \"local\"; console.log(x); // =&gt; local}foo();console.log(x); // =&gt; global 2. 전역 변수의 문제점암묵적 결합모든 코드가 전역 변수를 참조하고 변경할 수 있다. 변수의 유효 범위가 크면 코드의 가독성은 나빠지고 개발자가 예상하지 못한 변경사항이 발생할 위험성이 있다. 긴 생명 주기생명 주기가 길기 때문에 메모리 리소스 낭비도 심하고 중복될 가능성이 있고 만약 중복이 되면 의도하지 않은 재할당이 일어난다(특히 var 경우). 스코프 체인 상에서 종점에 존재전역 변수는 스코프 체인 상에 종점 존재하여, 변수 검색 속도가 느리다. 네임 스페이스 오염다른 파일 내에서 같은 이름에 변수나 함수가 같은 스코프 내에 존재할 경우 예상치 못한 결과를 가져올 수 있다. 3. 전역 변수 사용 억제 방법변수의 특별한 이유와 목적이 불분명할 때 가급적 지역 변수를 사용한다. 3.1 즉시 실행 함수함수 정의와 동시에 단 한번만 호출되는 함수를 말한다. 모든 코드는 즉시 시행 함수로 만들수 있고, 이 때 함수내에 모든 변수는 해당 함수에 지역 변수가 된다. 가장 많이 사용하는 방식으로 기본적인(심플한) 함수를 구현할 때 사용하면 좋다. 1234(function() { var foo = 10; // 즉시 실행 함수의 지역 변수});console.log(foo); // =&gt; ReferenceError: foo is not defined 이러한 방법은 전역 변수 생성을 막는 장점을 가지고 있다. 3.2 네임 스페이스 객체전역 변수처럼 사용하고 싶은 변수를 프로퍼티로 추가할 수 있는 네임 스페이스(전역) 객체를 생성한다. 123var MYSPACE = {}; // 네임 스페이스 객체MYSPACE.info = \"lee\";console.log(MYSPACE.name); 네임 스페이스 객체 안에 또 다른 프로퍼티를 추가하여 계층을 구성할 수 있다 123456var MYSPACE = {}; // 네임 스페이스 객체MYSPACE.info = { name: \"lee\", address: \"Soeul\"};console.log(MYSPACE.info.name); // lee 3.3 모듈 패턴클로저를 기반으로 클래스 형태로 관련된 변수, 함수를 모아 실행 함수로 감싸는 모듈을 만든다. 이는 전역 변수 억제, 캡슐화를 구현할 수 있다. 캡슐화외부로 정보를 노출 시키지 않는 정보 은닉(information hiding)이라고도 한다. 이것은 외부로 부터 제한된 접근 권한을 제공하여, 내부를 보호하는 가능을 한다. 자바스크립트는 public, private, protected등 접근은 제한자를 제공하지는 않지만, 전역 네일 스페이스의 오염을 막는 기능에 일부만 지원한다. 단 자바스크립트는 클로저로 프라빗 기능을 대신한다.","link":"/2019/05/09/TIL-190509/"},{"title":"TIL-190504","text":"6일차 (0504) - JavascriptJavascript - What I learn… 타입 변환과 단축 평가 타입 변환과 단축 평가1. 타입 변환이란? 자바스크립크는 개발자 의도에 의해 두가지 방시으로 값의 타입을 변경할 수 있다.첫째, 명시적 타입 변환(Explicit coercion) 또는 타입 캐스팅(Type casting)이라 한다. 개발자 의도에 따라 타입 값을 정의할 수 있다. 12var x = 10;var str = x.toString(); 둘째, 암묵적 타입 변환(Implicit coercion) 또는 타입 강제 변환(Type coercion)이라 한다 개발자 의도와 상관없이 자바스크립트 엔진에 의해 암묵적으로 타입 값이 변경 된다. 12var x = 10;var str = x + \"\"; 2. 암묵적 타입 변환암묵적 타입 변환은 개발자 의도에 다르게 작동할 수 있으나, 차제적으로 에러를 최소화 하기 위해 자바스크립트 엔진은 타입 변환을 평가할 때 문맥을 고려해 변환을 실행한다. 123456789// 피연산자가 문자열 타입일 때 가능, 이때 숫자형 타입은 + 연산을 진행한다var a = 5 + '10' // =&gt; 510// 피연산자\b가 모두 숫자 타입일 때 가능, 이때 문자형 피연산자는 * 을 할 수 없다.var a = 5 * '10' // =&gt; 50// 피연산자 또는 표현식이 불리언 타입일 때 가능, 조건에 따라 값이 불리언일 때.var a == !0 // trueif (2) {} 2.1 문자열 타입으로 변환자바스크립트는 문자열 타입으로 강제 변환하기 위해서 i + ‘’ 을 한다.이때 i는 숫자, 불리언, null, undefined, 심볼, 객체가될 수 있다. 1var a = 5 + \"10\"; //=&gt; \"12\" 이때 피연산자중 하나 이상에 문자열이 존대한다면, 다른 숫자열 피연산자를 문자화 한다. 1var e = `1+1 = ${2 + 2}`; 문자열 인터폴레이션(String interpolation)은 표현식의 평가 결과를 문자열 타입으로 암묵적 타입 변환한다. 2.2 숫자 타입으로 변환자바스크립트는 문자열 타입으로 강제 변환하기 위해서 + “i” 을 한다.이때 i는 숫자, 불리언, null, 심볼, 객체(“[]”)가될 수 있다. 12345678var a = 10 - \"2\"; // =&gt; 8var a = -\"10\" + 2; // =&gt; -8var b = 2 * \"10\"; // =&gt; 20var b = -\"2\" * \"10\"; // =&gt; -20var c = 10 / \"2\"; // =&gt; 5var c = 2 / -\"10\"; // =&gt; -0.2 즉 문맥상 피연산자는 숫자 타입이여야 한다. 이때 만약 산술 연산을 수행할 수 없으면 결과는 NaN을 반환한다. 12\"5\" &gt; 0; // true1 &lt; i &lt; 5; // false or true 비교연산자는 불리언 값을 만들어 낸다. 즉 이때에 피연산자는 숫자이여만 하고, 문자 값을 강제 변환 시킨다. 2.3 불리언 타입으로 변환if문 for문 또는 삼항 연산자의 조건식(conditional expression)은 논리적 참, 거짓을 반환해야 한다. 즉 엔진은 결과를 불리언 값으로 변환한다. 평가될 문맥중 false로 평다되는 값 false undefined null 0, -0 NaN ‘’(빈문자열) 3. 명시적 타입 변환래퍼 객체 생성자 함수 (String, Number, Boolean, object)를 new 연산자 없이 호출하거나 메소드를 사용하여 명시적으로 타입을 설정할 수 있다. 3.1 문자열 타입으로 변환문자열 타입이 아닌 값을 문자열 타입으로 변환 방법 String 생성자 함수를 new 연산자 없이 호출하는 방법 Object.Prototype.toString 메소드를 사용하는 방법 문자열 연결 연산자를 이용하는 방법 123456789// String 함수를 사용하기 (new 연산자 x)// 숫자 타입 =&gt; 문자열 타입console.log(string(5)); // =&gt; \"5\"//불리언 타입 =&gt; 문자열 타입console.log(string(true)); // =&gt; \"true\"// Object.prototype.toString 메소드 사용// 숫자 타입 =&gt; 문자열console.log((1).toString()); // =&gt; \"1\" 3.2 숫자 타입으로 변환3.3 불리언 타입으로 변환4. 단축 평가","link":"/2019/05/04/TIL-190504/"},{"title":"TIL-190507","text":"9일차 (0507) - JavascriptJavascript - What I learn… 함수 함수 1. 함수란?입력(input)을 받아서 출력(output)을 내보내는 과정을 만한다. 함수는 정의만으로 작동하지 않고, 호출을 해야 작동한다. 자바스크립트에서 함수는 객체이기 때문에 변수에 할당및 메서드로 호출이 가능하다. 또한 다른 함수로 인자(argument)로 전달하고, 프로퍼티를 지정할 수 있다. 2. 함수의 사용 이유함수는 재사용을 재사용하는 것이 효율적이다. 함수를 중복 사용하지 않거나 동일한 코드를 여러번 사용할 경우 유지 보수가 힘들고 에러를 줄일수 있다, 즉 신뢰성을 확보할 수있다. (호출 컨텍스트 invocation context로 this를 사용할 수 있다) 함수는 변수 이름처럼 이름(식별자)을 붙일 수 있다. 함수는 가독성을 고려하여 함수 식별자에 역할을 잘 설명하면서 적절한 이름을 붙여야 한다. 3. 함수 리터럴함수는 객체이기 때문에 객체 리터럴 표기법으로 생성할 수 있다. 즉 함수는 객체 리터럴로 표기할 수 있다. 123var foo = function bar(x, y) { return x + y;}; [함수 리터럴 구성] 함수명 함수명은 식별자이다. (함수 이름은 변수로서 객체가 변수에 할당된다.) 함수명은 함수 몸체 안에서만 참조할 수 있다. 기명 함수(named function), 익명 함수(anonymous function)으로 선언이 가능하다. 매개변수 (parameter) 0개 이상의 매개변수를 괄호로 감싸고 쉼표로 구분한다. 매개변수(parameter)는 인수(argument)를 할당 받는다. 매개변수는 함수 몸체에서 지역 변수처럼 취급된다. 함수 몸체 0개 이상에 문장을 포함하는 중괄호. 함수 호출시 일괄적으로 실행될 문들에 집합으로 실행 단위에 코드 블록[] 4. 함수 정의 함수 선언문 (Function Declaration/Function Statement) 123function add(x, y) { return x + y;} 함수 표현식(Function Expression) = 변수 호이스팅, 함수 호이스팅을 한다. 123var add = function add(x, y) { return x + y;}; Function 생성자 함수(Function Constructor) 1var add = new Function('x', 'y', 'return x + y'); 화살표 함수 (Arrow Function): ES6 1var add = (x, y) =&gt; x + y; 4.1 함수 선언문함수 선언문은 함수명을 반드시 써야한다. 함수 선언문은 문으로서 자바스크립트 엔진에 명령을 내리는 역활을 한다. 1function bar(x, y) {} 함수 선언문은 실행될 때 함수 객체를 생성하고, 객체가 변수에 할당된다. 즉 변수에 할당이 되지 않으면 함수를 사용할 수 없다. 함수 호이스팅 o 4.2 함수 표현식자바스크립트의 함수는 일급 객체이다. 변수 선언 + 변수 할당으로 구성되어 있다. 변수 선언과 초기화 단계가 한번에 된다. 함수 호이스팅 x 4.3 함수 생성 시점과 함수 호이스팅4.4 Function 생성자 함수4.5 화살표 함수5. 함수 호출6. 매개변수와 인수인수: argument = 함수 바깥에 존재인자: parameter = 매개변수 =함수를 받아주는 것으로 함수 내부와 외부를 연결하는 인터페이스이다 여기서 파라미터는 스코프가 함수 내부에 있다. 7. 인수 확인8. 매개변수의 개수9. 외부 상태의 변경과 함수형 프로그래밍10. 반환문11. 다양한 함수의 형태11.1 즉시실행함수단한번만 호출이 간능하다. 인위적인 스코프를 만들때/ 클로저를 만들때 사용 11.2 재귀 함수 (recursive function)함수 내부에서 자신을 호출하는 방식. factorial()로 호출한다. 11.3 중첩 함수 (nested function)내부 함수(Inner function)이라고 불리기도 한다. 외부 함수에 존재하고, 외부에서 소멸 된다. 11.4 콜백 함수","link":"/2019/05/07/TIL-190507/"},{"title":"TIL-190511","text":"13일차 (0511) - JavascriptJavascript - What I learn… 프로퍼티 정의 1. 프로퍼티 정의란?2. 내부 슬롯/메소드3. 접근자 프로퍼티4. 프로퍼티 어트리뷰트","link":"/2019/05/11/TIL-190511/"},{"title":"TIL-190510","text":"12일차 (0510) - JavascriptJavascript - What I learn… let, const와 블록 레벨 스코프 let, const와 블록 레벨 스코프1. var 키워드로 선언한 변수의 문제점ES5까지 변수를 선언할 수 있는 유일한 방법은 var 키워드를 사용하는 것이었다 1.1 변수 중복 선언 허용var 키워드 변수 선언은 중복 선언이 가능하다. 변수 중복 선언은 문법적으로 허용되지만 사용하지 않는 것이 좋다. 1.2 함수 레벨 스코프var 키워드로 선언한 변수는 오직 함수의 코드 블록을 지역 스코프로 인정한다. 즉 함수 외부에서 선언한 변수는 모두 지역 변수가 된다. 123456var x = 1; // 전역 변수if (true) { var x = 10; // 전역 변수}console.log(x); // =&gt; 10 for문 안에서 var도 전역 변수로 인정한다. 1for (var i = 0; i &lt; 3; i--) {} 1.3 변수 호이스팅var 변수 선언은 자바스크립트 엔진에 의해 암묵적으로 스코프 선두로 끌어 올려진 것 처럼 동작한다. 그렇지만 할당문 이전에 변수를 참조하면 언제다 undefined를 반환 한다. 12345678// foo가 초기화 되면서 값이 할당이 안된다console.log(foo); //undefinedfoo = 123;// 런타임 이전에 암묵적으로 실행된다.(호이스팅)// + 프로그램 흐름상 맞지 않고, 가동성이 저하, 오류 발생등에 문제가 발생된다.console.log(foo); //123var foo; 2. let 키워드ES6에서는 let과 const 키워드가 생겼다. 동일하게 변수를 선언할 때 사용한다. 2.1 변수 중복 선언 금지let은 동일한 이름을 갖는 변수를 중복 선언하면 문법 에러(syntaxError)가 발생한다. 1234let bar = 10;let bar = 15; // SyntaxError Identifier 'bar' has already been declaredbar = 20; // let을 제외하고 변수에 재할당은 가능하다. 2.2 블록 레벨 스코프 (Block-level-scope)let 키워드로 선언한 변수는 모든 코드 블록 (함수, if문, for문, while문, try.catch문 등)을 지역 스코프로 인정하는 블록 레벨 스코프(block-level-scope)를 따른다 123456789let foo = 123; // 전역 변수{ let foo = 456; // 지역 변수 let bar = 456; // 지역 변수}console.log(foo); // 123console.log(bar); // ReferenceError foo는 지역 변수, 전역 변수가 존재하게 된다. bar는 지역 정보로 전역에서는 참조할 수 없다. 2.3 변수 호이스팅let 키워드로 선언한 변수는 표면적으로 호이스팅이 발생하지 않는 것처럼 보인다. let 키워드 선언한 변수는 “선언 단계”와 “초기화 단계”가 분리되어 진행된다. 런타임 이전에 자바스크립트 엔지에 의해 암묵적 선언 단계가 먼저 실행된다 변수 선언문에 도달했을 때 변수 초기화 단계에 들어간다. // ReferenceError foo is not defined1let foo; 초기화 단계가 되기전에 참조를 하면 참조 에러(ReferenceError)가 발생한다. 즉 선언은 되었지만 초기화를 하지 않아서 메모리 공간이 확보가 되기 않아 변수를 참조할 수 없다. 스코프의 시작 부터 초기화 지점까지 구간을 일시적 사각지대 (Temporal Dead Zone: TDZ)라고 부른다. 2.4 전역 객체와 let전역 함수는 전역 객체의 프로퍼티가 된다.즉 전역 객체의 프로퍼티를 참조할 때 window를 생략할 수 있다. 그러나 let으로 선언된 전역 변수는 전역 객체 window의 프로퍼티가 아니다. 3. const 키워드const(constant)상수를 선언하기 위해 사용한다. const의 특징은 let과 유사 하지만, 더욱 엄격한 변수 관리에 유용하다. 3.1 선언과 초기화const 키워드로 선언한 변수는 재할당이 완전히 금지된다. 123const a = 100;a = 150; // TypeError Assignment to constant variableconst a = 200; // SyntaxError 'a' has already been declared 한번 const로 선언된 변수는 어떠한 방법으로도 재할당이 불가능한 상수에 값을 가진다. const 키워드 선언은 변수 선언 동시에 할당이 반드시 이루어져야 한다. 그렇지 않으면 문법 에러(SyntaxError)가 발생한다. 또한 const는 let과 같이 블록 레벨 스코프이다. 1const bar; // SyntaxError: Missing initializer in const declaration 3.2 상수상수는 가독성과 유지보수의 편의를 위해 사용하고 반드시 어떤 의미로 사용하였는지 명확한 단어로 써야한다. 여러 단어의 조합의 경우 단어의 첫글자를 대문자 혹은 단어 사이에 언더스코어(_)로 구분한다. 프로그램 전체에서 공통으로 사용하거나 고정된 값일 경우 상수로 정의하면 유지보수가 편하다. (특히 프로그랜 전체에 사용 되고, 중요해서 값을 보호하거나, 나중에 바뀔수 있는 정보를 const로 선언한다) 3.3 const 키워드와 객체const 선언된 값은 변경될 수 없는 값(immutable value)이고 원시값는 할당 값을 변경할 수 없다. 그러나 const 키워드 선언된 변수에 할당돤 객체는 변경 가능한 값(mutable value)이다. 따라서 const는 재할당을 금지할 뿐 불변(immutable)을 의미하지 않는다. 즉 const 할당된 변수를 제와한 객체 (프로퍼티 추가, 삭제, 수정)을 변경은 자유롭다. 단 객체 내용이 변경되어도 변수의 주소(memory address)는 변경되지 않는다. 123456789const item = { book: \"title\"};// 객체 변경item.book = \"subtitle\";// 객체 추가item.pencil = \"wood\"; 4. var vs. let vs. const","link":"/2019/05/10/TIL-190510/"},{"title":"TIL-190513","text":"15일차 (0513) - JavascriptJavascript - What I learn… 함수와 일급 객체 함수와 일급 객체값처럼 쓸수 있는 객체 1.일급 객체함수는 객체이고 값처럼 사용할 수 있다. 자바스크립트 함수는 일급 객체(first-class-object)이다. 일급 객체는 다음과 같은 조건을 만족해야한다. 무명의 리터럴로 생성할 수 있다. 즉, 런타임에 생성이 가능하다. 변수나 자료 구조(객체, 배열 등)에 저장할 수 있다 함수의 매개변수에게 전달할 수 있다. 함수의 반환값으로 사용할 수있다 함수는 일급 객체로서 함수를 호출할 수 있고 함수 고유의 프로퍼티를 소유할 수 있므로 일반 객체화 차이가 있다. 123456789101112131415161718192021222324252627282930313233343536```함수는 무명 리터럴로 생성할 수 있으므로 코드 어디서든 정의할 수 있고 코드듣 런타임(runtime)에 함수가 생성된다. 즉 일급 객체란 함수에 값을 자유롭게 사용할 수 있고 파라미터(parameter)로 값을 전달 및 반환할 수 있다.&gt; 함수형 프로스래밍&gt; 순수 함수 (pure function)와 보조 함수의 조합을 통해 외부 상태를 변경하는 부수 효과(side-effect)를 최소화아혀 불변성(immutability)을 지향하는 프로그래밍 패러다임이다.&gt; 즉, 변수의 생명주기를 최소화하여 오류를 최소화하고, 조건문, 반복문의 복잡성을 최소화하여 가독성을 높인다.#### 2. 함수 객체의 프로퍼티함수는 프로퍼티를 가질 수 있는 객체이다.argument, caller, length, name, prototype = 고유 프로퍼티#### 2.1 arguments 프로퍼티함수 객체의 argument 프로퍼티 값은 argument의 객체이다. argument객체는 함수가 호출되면 순회 가능한(iterable) 유사 베열 객체(array-like-object)로서 argument(인수)들의 정보를 담고 있게 된다. 이는 함수 내부에서 지역 변수로 사용이되며, 함수 외부에서는 사용할 수 없다.가변 인자 함수는 argument 객체는 매개변수 개수를 확정할 수 없다.#### 2.2 caller 프로퍼티함수 객체 caller 프로퍼티는 함수 자신을 호출한 함수를 가르킨다.#### 2.3 length 프로퍼티정의된 함수에 매개변수의 개수를 가르킨다.```javascriptfunction foo() {}console.log(foo.length); // =&gt; 0function bar(x, y) { return x + y;}console.log(bar.lenght); // =&gt; 2 함수에 매개변수의 개수를 가르키는 length 프로퍼티 와 argument에 parameter의 개수를 가르키는 객체의 length 프로퍼티는 다르다. 2.4 name 프로퍼티함수 객체의 함수명을 나타낸다. ES5와 ES6에는 기능적 차이가 있는데, ES5에서는 name property는 빈 문자열을 값으로 갖고, ES6에서는 함수 객체를 가르키는 변수명을 값으로 갖는다. 12345678// 함수 표현식 (함수명 foo를 가진 함수)var funcNamed = function foo() {};console.log(funcNamed.name); // foo, funcNamed는 식별자로 함수를 호출할 때 사용한다. 단 함수 내부에서 재귀 호출 할때 foo를 사용한다 (함수 내부에서만 유효)// 익명 함수 표현식 (함수를 가르키는 변수명 funcAnonymous을 가진 함수)var funcAnonymous = function() {};console.log(funcAnonymous.name); // funcAnonymous// ES5, ES6에 따라 다른 의미를 가진다 함수명과 함수를 가르키는 변수명은 의미다 다르다. 함수를 호출을 할 때 함수를 가르키는 변수명으로 호출한다. 2.5 proto 접근자 프로퍼티모든 객체는 [[prototype]]이라는 내부 슬롯을 갖는다. 내부 슬롯은 객체 지향 프로그램의 상속을 구현하는 객페를 가르킨다. [[prototype]]의 내부 슬롯이 가르키는 프로토타입 객체에 접근하기 위해 _ _ proto _ _ 접근자를 사용한다. 단 내부 슬롯을 직접 접근할 수 없다. 그렇지만 접근자를 사용하면 간접적으로 접근을할 수 있다. 2.6 prototype 프로퍼티prototype 프로퍼티는 일반 객체에서는 존재하지 않으며, 함수 객체만이 소유하는 프로퍼티이다. prototype은 함수가 객체를 생성하는 생성자 함수로 사용될때, 생성자 함수는 인스턴스의 프로토차입 객체를 가르킨다.","link":"/2019/05/13/TIL-190513/"},{"title":"TIL-190512","text":"14일차 (0512) - JavascriptJavascript - What I learn… 생성자 함수에 의한 객체 생성 생성자 함수에 의한 객체 생성객체 리터럴 표기법은 간단한 객체 생성 방법중에 가장 일반적이다. 객체는 리터럴 표기법 이외에도 다양한 방법으로 생성할 수 있다. 1. Object 생성자 함수자바스크립트에서 제공하는 기본적인 빌트인 함수 이다. new 연산자와 Object() 생성자 함수를 호출하면 빈 객체를 생성한다. Object 함수는 프로퍼티 또는 메소드를 추가하여 객체를 완성할 수 있다.(new는 생략되어도 엔진에서 자동적으로 붙여준다.) 빌트인 함수Object, String, Number, Boolean, Function, Array, Data, RegExp 등의 생성자 함수를 제공한다. Object 함수는 인수에 따라 암묵적으로 객체를 바꾼다(형변환). 이러한 특징 때문에 특별한 이유를 제외하고 잘 사용하지 않는다. 12const obj = new Object(\"hello\"); // object보다, string, number를 사용한다.console.log(obj, typeof obj); // =&gt; String {\"hello\"} \"object\" 생성자(constructor) 함수란?new 연사자와 함께 호출하여 객체(인스턴트)를 생성하는 함수.생성자 함수에 의해 인스턴스 객체를 생성한다. 인스턴스(instance)생성자도 함수도 객체이기 때문에 생성자 함수나 클래스가 생성한 객체를 인스턴스리고 한다. 인스턴스는 객체가 메모리에 저장되어 실제 존재하는 것 1const empty = new Object(); 2. 생성자 함수 (constructor function)객체를 생성하기 위한 용도로 사용하는 것이 생성자 함수 이다 2.1 객체 리터럴에 의한 객체 생성 방식의 문제점객체 리터럴은 하나의 객체를 만드는 방법이다. 그렇지만 동일한 프로퍼티를 갖는 여러 객체를 생성할 수 없다.따라서 비효율적인 프로퍼티를 기술할 수 밖에 없다. 1234567891011121314const box1 = { width: 10, getDiameter() { return 2 * this.radius; }};console.log(circle1.getDiameter()); // 10const box2 = { width: 20, getDiameter() { return 2 * this.radius; }};console.log(circle2.getDiameter()); // 20 객체는 프로퍼티를 통해 객체 고유의 상태(state)를 표현한다. 그리고 메소드를 통해 데이터 상태인 프로퍼티를 참조하고 조작하는 동장(behavior)을 표현한다. 2.2 생성자 함수에 의한 객체 생성 방식 장점2.3 내부 메소드 [[Call]]과 [[Constructor]]함수 메소드가 가지고 있는 내부 메소드일반함수로 호출 =&gt; [[Call]]new 연산자로 호출 =&gt; [[Constructor]] =&gt; 생성자 함수 2.4 constructor와 non-constructor의 구분=&gt; 함수은 생성자 함수로 호출 못한다 2.5 생성장 함수의 동작 방식2.6 new 연산자new 연산자와 함께 호출되면 해당 함수는 생성자 함수로 동작한다. 즉 new 연산자와 함께 호출된 함수는 constructor이다. 2.7 new.target연산자 없이 함수를 호출하는 것을 방지하기 위해 파스칼 케이스 켄벤션을 사용한다. new.target은 함수내에서 변수처럼 사용되고, 메타 프로퍼티(meta property)라고 부른다. 수업1234567891011121314151617181920212223function person() { // 1. 빈 객체를 생성하고 this 에 바인딩 this.name = \"lee\"; this.sayHello = function() { console.log(`hello ${this.name}!`); // this 함수가 호출 되었을때 실행 };}const me = new person();console.log(me);me.sayHello(); // hello lee!function person(name) { // 1. 빈 객체를 생성하고 this 에 바인딩 this.name = name; this.sayHello = function() { console.log(`hello ${this.name}!`); // this 함수가 호출 되었을때 실행 };}const me = new person(\"lee\");me.sayHello(); // hello lee!const you = new person(\"kim\");you.sayHello(); // hello kim!","link":"/2019/05/12/TIL-190512/"},{"title":"TIL-190514","text":"16일차 (0514) - JavascriptJavascript - What I learn… 프로토타입 프로토타입 (Prototype) 객체 지향은 클레스 기반에 객체지향 모델을 가지고 있다. 객체 지향은 기본적으로 모든것을 객체로 본다. 객체는 프로토타입으로부터 프로퍼티 객체는 상속받는다. new 생성자 함수는 prototype을 기본적으로 생성한다. (객체 리터럴로 생성된 객체도 프로토 타입을 갖는다.) 클래스ES6에서 새롭게 도입된 새로운 객체지향 모델이다. 클래스는 같은 프로토타입 객체로 부터 프로퍼티를 상속 받은 객체들에 집합이다. 프로토타입 기반 패턴의 문법적 설탕(Syntactic sugar)이라고 본다. 1. 객체지향 프로그래밍 (Object Oriented Programming, OOP)절차지향적 관점에서 벗어나 여러 개의 독립적 단위(Object) 들의 집합을 표현하는 프로그래밍 패러다임을 말한다. 이것은 실제 환경을 이해하는 방식을 프로그래밍에 접목 시키려는 방식에 표현 방식을 가지고 있다. 사물을 인지하고 이해하기 위해서 특정한 속성(Attribute, Property), 즉 특징을 알아야한다. 이러한 방식으로 프로그램에 필요한 속성을 간추려 표현해야 하는데 이를 추상화(abstraction)이라고 한다. 객체지향 프로그래밍은 객체의 상태(state), 데이터 상태를 조작하는 동작(behavior)를 논리적인 단위로 묶는다. 이런 복합적인 자료 구조를 객체(object)라고 한다. (상태 데이터 = 바뀔 값) 객체 상태 = 프로퍼티(property)동작 = 메소드(method) 2. 상속(inheritance)과 프로토타입객체 지향 프로그래밍의 핵심 개념으로 상위(부모) 객체의 프로퍼티(property) 또는 메소드(method)를 하위(자식) 객체가 상속 받아 자유롭게 사용할 수 있다. 12345678910111213141516171819202122// 생성자 함수function Circle(radius) { this.radius = radius;}// this.getArea = function() {// return Math.PI * Math.pow(this.radius, 2);// };// =&gt; 불필요하게 생성되는 모든 인스턴스가 this.getArea 메소드를 갖는다.// =&gt; 메모리를 낭비하고 있다. (퍼포먼스가 떨어진다)Circle.prototype.getArea = function() { return Math.PI * Math.pow(this.radius, 2);};// Prototype 기반으로 상속을 구현한다. (prototype에 바인딩 되어있다!)//인스턴스 생성const circle1 = new Circle(5);const circle2 = new Circle(10);console.log(circle1.getArea === circle2.getArea);console.log(circle1.getArea());console.log(circle2.getArea()); 인스턴스는 개별적으로 다른 프로퍼티 값을 가지고 상위 .prototype으로 메소드를 할당하여 인스턴스가 필요할 getArea 메소드가 필요할 때 상속을 받을수 있게 구현한다. 3. 프로토타입 객체프로토타입 객체는 상속에 목적으로 상위에서 하위로 프로퍼티, 메소드를 제공한다. 이때 하위 객체는 상위 객체에 property를 자유롭게 사용이 가능하다. 모든 객체는 생성될 때 [[prototype]]이라는 내부 슬롯을 만든고 참조 값을 저장한다. 프로토타입은 생성 방식에 의해 결정되는데, 객체 리터럴로 생성된 객체는 Object.prototype을 가지고, 생성자 함수는 생성자 함수의 prototype 프로퍼티에 바인딩한다. 모든 생성자 함수는 =&gt; 생성자 함수.prototype과 연결되어 있다. ( prototype )모든 생성자 함수는 =&gt; 객체(Object)와 연결되어 있다. ( constructor )모든 객체는 =&gt; 생성자 함수.prototype과 연결되어 있다. ( _ _proto _ _ ) 3.1 객체의 _ proto _ 접근자 프로퍼티모든 객체(object)는 _ proto _ 접근자 프로퍼티를 통해 [[prototype]] 내부 슬롯에 접근할 수 있다.(object.prototype / 생성자.prototype) _ prototype _는 접근자 프로퍼티이다.내부 슬롯 접근은 직접 접근이 불가능하고, 다른 프로퍼티에 값을 읽거나, 저장할 때 사용하는 접근자 함수(Accessor function) 프로퍼티다. Object.prototype의 프로퍼티는 getter/setter 함수라고 부르는 접근자 함수를 통해 [[property]] 내부 슬롯의 값을 접근한다. get _ prototype _ set _ prototype _ 3.2 함수 객체의 prototype 프로퍼티 3.3 프로타입의 constructor 프로포티와 생성자 함수 4. 리터럴 표기법에 의한 생성된 객체의 생성자 함수와 프로토타입 5. 프로토타입의 생성 시점 5.1 사용자 정의 생성자 함수와 프로토타입 생성 시점 5.2 빌트인 생성자 함수와 프로토타입 생성 시점 6. 객체 생성 방식과 프로토타입의 결정 6.1 객체 리터럴에 의해 생성된 객체의 프로토타입 6.2 Object 생성자 함수에 의해 생성된 객체의 프로토타입 6.3 생성자 함수에 의해 생성된 객체의 프로토타입 7. 프로토타입 체인 8. 캡슐화 9. 오버라이딩과 프로퍼티 쉐도잉 10. 프로토타입의 교체 10.1 생성자 함수에 의한 프로토타입의 교체 10.2 인스턴스에 의한 프로토타입의 교체 11. instanceof 연산자 12. Object.create에 의한 직접 상속 13. 객체 리터럴 내부에서 proto에 의한 직접 상속 14. 정적 프로퍼티/메소드 15. 프로퍼티 존재 확인 16. 프로퍼티 열거","link":"/2019/05/14/TIL-190514/"},{"title":"TIL-190515","text":"17일차 (0515) - JavascriptJavascript - What I learn… 엄격 모드 엄격 모드1. Strict Mode란?ES5부터 지원되는 기능으로, 개발자 의도와는 다르게 암묵적 변환에 의한 에러를 대비하기 위한 해결 책이다. 이는 자바스크립트 언어의 문볍을 보다 엄격히 적용하여 기존에 오류 발생 가능성이 있는 코드에 명시적인 에러를 발생 시킨다. 1234function foo() { x = 10;}console.log(x); 이때 x는 암묵적으로 전역 변수로 처리 되고 전역 객체에 x를 동적 생성한다. 그래서 반드시 변수 선언시 var, let, const로 선언해야 한다. 또한 스코프 상에서 x는 함수 내부에서 존재 하므로 x를 부를시 함수 내부에 console.log()를 써야 한다. 추가적으러 코딩 컨벤션을 설정 파일 형태로 정의하고 제안할 수 있다. 2. Strict Mode의 적용strict mode를 적용하려면 전역(스크립트 전체) 또는 함수(동일 스코프상)에 선두에 use strict; 를 추가한다. 12345678\"use strict\";function foo() {}// orfunction bar() { \"use strict\";} 코드에 선두에 위치하지 않으면 동작하지 않는다. 3. 전역에 strict mode를 적용하는 것은 피하자전역으로 strict mode를 적용하는 것은 외부 서드 파티 라이브러리를 사용 하는 경우 오류를 발생 시킬 위험이 있다. 4. 함수 단위로 strict mode를 적용하는 것은 피하자strict mode가 적용된 함수가 참조할 함수 외부의 컨텍스트에 적용이 안되면 에러가 발생할 수 있다. 즉 strict mode는 즉시 실행 함수로 감싼 스크립트 단위로 적용하는 것이 좋다. 5. strict mode가 발생시키는 에러5.1 암묵적 적역 변수var, let, const로 선언하지 않은 변수를 참조하면 referenceError를 발생 시킨다. 1234567(function() { \"use strict\"; x = 1; console.log(x); //=&gt; ReferenceError x is not defined})(); 5.2 변수, 함수, 매개변수의 삭제delete 연산자로 변수, 함수, 매개변수를 삭제하면 SyntaxError가 발생한다. 1234567891011(function() { \"use strict\"; let a = 10; delete a; // =&gt; SyntaxError function bar (b){ delete b; // =&gt; SyntaxError } delete bar; // =&gt; SyntaxError}()); 5.3 매개변수 이름의 중복중복된 함수 파라미터를 사용하면 SyntaxError를 발생한다. 123456789(function() { \"use strict\";// SyntaxErrorfunction foo (x,x){ return x + x;}console.log(foo(1,2));}()); 5.4 with 문의 사용with 문을 사용하면 SyntaxError가 발생한다. 12345678(function () { 'use strict'; // (function () { 'use strict'; with({x : 1}){ console.log(x); }}()); 5.5 일반 함수의 thisthis에 undefined가 바인딩되면서 에러를 발셍시키지 않는다(new 생성자 함수에서는 작동한다). 12345678910111213(function() { \"use strict\"; function foo() { console.log(this); // =&gt; undefined } foo(); function bar() { console.log(this); // bar } new bar(); // new 생성자 함수로 호출})();","link":"/2019/05/15/TIL-190515/"},{"title":"TIL-190517","text":"19일차 (0517) - JavascriptJavascript - What I learn… this this 1. this 키워드객체는 프로퍼티로 표현되는 상태 데이터와 메소드로 표현되는 논리적 단위의 복합적 자료 구조이다. (this)는 자신이 속한 객체를 가르키는 식별자를 참조할 수 있어야 한다. 즉 this는 객체의 프로퍼티, 메소드를 참조(호출)하기 위한 자기 참조 객체로 평가된다. 객체 리터럴 방식으로 생성한 객체의 경우, 매소드 내부에서 자신이 속한 객체를 가르키는 식별자를 재귀적으로 참조할 수 있다. this는 스코프(Scope) 유효범위가 없고 중첩 함수는 호출자의 this 값을 상속 받지 않는다. (this는 코드 어디든지 참조가 가능하다.) 만약 중첩 함수가 메서드 형태로 호출되면, this 값은 해당 함수의 호출 대상이된다. (지역변수) 만약 함수 형태로 호출되면, this 값은 global(window)를 가르킨다. 2. 함수 호출 방식과 this 바인딩this가 가르키는 값은 함수 호출 방식에 따라 바인딩될 객체가 동적으로 결정된다. 또한 엄격 모드(strict mode) 역시 바인딩에 영향을 준다. 엄격 모드가 적용된 함수 내부의 this에는 undefined 가 바인딩된다 바인딩 (binding)식별자와 값을 연결하는 과정을 의미한다. 즉 변수 할당에 의해 다른 값이 바인딩된다. Lexiacal scope와 this 바인딩 시기랙시컬 스코프 (Lexical scope)는 상위 스코프를 결정하는 방식으로 함수 정의가 평가하면서 함수 객체가 생성되는 시점에 상위 스코프를 결정한다. 그러나 this는 함수가 호출되는 시점에 바인딩할 객체를 결정한다 [함수 호출 방식] 123const foo = function() { console.dir(this); // 자바스크립트 속성들을 출력합니다.}; 일반 함수 호출 123// 일반적인 방식으로 foo를 호출.// this는 전역 객체 window를 가르킨다.foo(); // =&gt; window 메소드 호출 1234// foo 함수를 obj의 프로퍼티의 값으로 할당, 호출.// this는 obj 메소드에 할당되어 호출된다.const obj = { foo };obj.foo(); // obj 생성자 함수 호출 123// foo 함수를 new 연산자와 함께 생성자 함수로 호출.// this는 생성자 함수가 생성할 인스턴스 instance를 가르킨다.const instance = new foo(); // instance Function.prototype.apply/call/bind 메소드에 의한 간접 호출 1234567// function.prototype.apply/call/bind 메소드에 의해 간접 호출// this는 인수(argument)에 의해 결정된다.const bar = { name: 'lee' };foo.call(a); // afoo.apply(b); // bfoo.bind(c); // c 2.1. 일반 함수 호출기본적으로 this에는 전역 객체(Global object)가 바인딩된다. (전역 함수, 중첩 함수 포함). 메소드 내에서 정의한 중첩 함수도 일반 함수로 호출 되면 내부에 this 또한 전역 객체에 바인딩 된다.(콜백 함수도 일반 함수로 호출되면 결과는 같다) 12345678function foo() { console.log(this); // window function baa() { console.log(this); // window } bar();}foo(); 콜백 함수에서 this와 프로퍼티 활용한 this 호출 12345678910111213141516var value = 10;const bar = { value: 100, foo() { console.log(this); // {value: 100, foo: ƒ} console.log(this.value); // 100 // 콜백 함수 내부의 this에는 전역 객체가 바인딩된다. setTimeout(function() { console.log(this); // window console.log(this.value); // 10 }, 100); }};bar.foo(); 2.2. 메소드 호출2.3. 생성자 함수 호출2.4. Function.prototype.apply/call/bind 메소드에 의한 간접 호출","link":"/2019/05/17/TIL-190517/"},{"title":"TIL-190519","text":"21일차 (0519) - JavascriptJavascript - What I learn… 배열 배열 (Array)1. 배열의 생성1.1 배열 리터럴1.2 Array() 생성자 함수2. 배열 요소의 추가와 삭제2.1 배열 요소의 추가2.2 배열 요소의 삭제3. 배열의 순회4. Array Property4.1 Array.length5. Array Method5.1 Array.isArray(arg: any): boolean ES55.2 Array.from ES65.3 Array.of ES65.4 Array.prototype.indexOf(searchElement: T, fromIndex?: number): number 🔒 ES55.5 Array.prototype.concat(…items: Array&lt;T[] | T&gt;): T[] 🔒 ES35.6 Array.prototype.join(separator?: string): string 🔒 ES15.7 Array.prototype.pop(): T | undefined ✏️ ES35.8 Array.prototype.push(…items: T[]): number ✏️ ES35.9 Array.prototype.reverse(): this ✏️ ES15.10 Array.prototype.shift(): T | undefined ✏️ ES35.11 Array.prototype.slice(start=0, end=this.length): T[] 🔒 ES35.12 Array.prototype.splice(start: number, deleteCount=this.length-start, …items: T[]): T[] ✏️ ES3","link":"/2019/05/19/TIL-190519/"},{"title":"TIL-190520","text":"22일차 (0520) - JavascriptJavascript - What I learn… 배열 고차 함수 배열 고차 함수 (Higher order function)함수를 parameter로 전달 받거나 함수를 결과로 반환하는 함수. 즉 고차 함수는 parameter를 받아 호출하거나 클로저를 생성한다. 함수는 정의되면 렉시컬 스코프에 따라 상위 스코프가 결정된다. 함수는 자신에 상위 스코프를 항상 가지고 다닌다. 고차함수는 함수를 인수로 전달 하거나 함수를 리턴하는 조건을 가진 함수이다 or 둘다 이거나. (알고리즘 ‘이상한 문자열’ 풀이 참고). 외부상태의 불변성을 추구한다. (외부 상태에 의존성이 없다). 복자성 1. Array.prototype.sort(compareFn?: (a: T, b: T) =&gt; number): this ✏️ ES1배열의 요소를 정렬한다 (원본을 배열을 변형한다). 1fruits.sort().fruits.reverse(); // sort를 반대로 123456789points.sort(function(a, b) { return a - b;});points.sort(function(a) { return b - a; b;});return a[key] &gt; b[key] ? 1 : a[key] &lt; b[key] ? -1 : 0; 2. Array.prototype.forEach(callback: (value: T, index: number, array: T[]) =&gt; void, thisArg?: any): void 🔒 ES5기본적인 리턴값이 undefined 3. Array.prototype.map(callbackfn: (value: T, index: number, array: T[]) =&gt; U, thisArg?: any): U[] 🔒 ES5콜백 함수의 반환값(결과값)으로 새로운 배열을 생성하여 반환한다. 리턴값으로 새로운 배열을 만들기 때문에 새로운 변수로 받아 반드시 리턴 해야한다. 4. Array.prototype.filter(callback: (value: T, index: number, array: Array) =&gt; any, thisArg?: any): T[] 🔒 ES5원본배열을 수정하지 않고 if 대신에 조건을 반환한다. 5. Array.prototype.reduce(callback: (state: U, element: T, index: number, array: T[]) =&gt; U, firstState?: U): U 🔒 ES56. Array.prototype.some(callback: (value: T, index: number, array: Array) =&gt; boolean, thisArg?: any): boolean 🔒 ES57. Array.prototype.every(callback: (value: T, index: number, array: Array) =&gt; boolean, thisArg?: any): boolean 🔒 ES58. Array.prototype.find(predicate: (value: T, index: number, obj: T[]) =&gt; boolean, thisArg?: any): T | undefined 🔒 ES69. Array.prototype.findIndex(predicate: (value: T, index: number, obj: T[]) =&gt; boolean, thisArg?: any): number 🔒 ES6","link":"/2019/05/20/TIL-190520/"},{"title":"TIL-190521","text":"23일차 (0521) - JavascriptJavascript - What I learn… 문서 객체 모델 문서 객체 모델(Document Object Model)1. DOM (Document Object Model)2. DOM tree3. DOM Query / Traversing (요소에의 접근)3.1 하나의 요소 노드 선택(DOM Query)3.2 여러 개의 요소 노드 선택(DOM Query)3.3 DOM Traversing (탐색) 4. DOM Manipulation (조작)4.1 텍스트 노드에의 접근/수정4.2 어트리뷰트 노드에의 접근/수정4.3 HTML 콘텐츠 조작(Manipulation)4.4 DOM 조작 방식4.5 insertAdjacentHTML()4.6 innerHTML vs. DOM 조작 방식 vs. insertAdjacentHTML() 5. style","link":"/2019/05/21/TIL-190521/"},{"title":"TIL-190522","text":"24일차 (0522) - JavascriptJavascript - What I learn… 정규표현식 RegExp 정규표현식 (Regular Expression)1. 정규표현식(Regular Expression)1.2 플래그1.2 패턴1.3 자주 사용하는 정규표현식2. Javascript Regular Expression2.1 RegExp Constructor2.2 RegExp Method2.2.1 RegExp.prototype.exec(target: string): RegExpExecArray | null ES32.2.2 RegExp.prototype.test(target: string): boolean ES3","link":"/2019/05/22/TIL-190522/"},{"title":"TIL-190523","text":"25일차 (0523) - JavascriptJavascript - What I learn… 객체 리터럴 프로퍼티 기능 확장 객체 리터럴 프로퍼티 기능 확장 (Enhanced Object property) 1. 프로퍼티 축약 표현프로퍼티는 값으로 변수에 할당된 값일 수도 있으며 프로퍼티 이름과 값으로 구성된다. ES6에서는 프로퍼티의 이름을 생략해도 자동 생성된다. 12345678910111213// ES5var x = 1, y = 2;var foo = { x: x, y: y};// ES6var foo = { x, y };console.log(foo); // {x: 1, y: 2} 2. 프로퍼티 키 동적 생성문자열, 문자열로 반환 가능한 값을 표현식을 통해 동적으로 생성할 수 있다. ([]로 묶어야 한다) 123456789101112131415161718let item = 'work';let i = 0;//ES5// 객체 리터럴 외부에서 []로 동적 생성한다.var obj = {};obj[item + '-' + ++i] = i;obj[item + '-' + ++i] = i;//ES6// 객체 리터럴 내부에서 프로퍼티를 동적으로 생성할 수 있다.var obj = { [`${item}-${++i}`]: i, [`${item}-${++i}`]: i};console.log(obj); // {}item-1: 1, item-2: 2} 3. 메소드 축약 표현메소드 선언은 프로퍼티 값으로 함수 선언식을 할당한다 12345678910111213141516//ES5var item = { name: 'pen', alert: function(){ console.log('this is' + this.name); }};//ES6// 축약 표현으로 function을 생략할 수 있다.var item = { name 'pen', alert(){ console.log('this is' + this.name); }} 4. _ proto _ 프로퍼티에 의한 상속ES6에서는 _ proto _를 직접 설정할 수 있다. 즉 객체 리터럴로 생성한 객체는 _ proto _으로 직접 바잉딩을 설정할 수 있다. 단 ES5에서는 Object.crete() 함수를 사용하여 객체 리터럴을 상속한다. 12345678910111213141516171819let upper = { name: 'upper', alert (){ console.log('this is' + this,name) }}//ES5var lower = Object.create(upper);lower.name = 'child'//ES6var lower = { _ _proto_ _: upper, name: 'lower'}upper.alert(); // this is upperlower.alert(); // this is lower","link":"/2019/05/23/TIL-190523/"},{"title":"TIL-190524","text":"26일차 (0524) - JavascriptJavascript - What I learn… 디스트럭처링 디스트럭처링 (Destructuring)배열 또는 리터랄에서 필요한 값만 추출하여 변수에 할당, 반환 할 때 사용한다. 즉 구조화된 배열 또는 객체를 Destructuring(비구조화)하여 개별적인 변수에 할당하는 것을 말한다. 1. 배열 디스트럭처링 (Array destructuring)변수 할당을 위한 배열 디스트럭처링 1234567891011121314// ES5var arr = [1, 2, 3];var zero = arr[0];var one = arr[1];var two = arr[2];// ES6let arr = [1, 2, 3];// 할당 연산자는 왼쪽에 배열 형태의 변수 리스트가 필요let [zero, one, two] = arr;console.log(zero, one, two); // 1 2 3 ES6는 배열은 베열의 인덱스 기준으로 추출하여 변수 리스트에 할당한다. (오른쪽에서 왼쪽으로 할당한다) 123456789101112let x, y, z;[x, y, z] = [1, 2, 3];// 동치let [x, y, z] = [1, 2, 3];console.log(x); // 1console.log(y); // 2console.log(z); // 3console.log(1); // 1console.log(2); // 2console.log(3); // 3 2. 객체 디스트럭처링 (Object destructuring)ES5는 변수 할당을 위해 프로퍼티 이름(키)응 사용해야 한다.ES6는 프로퍼티 이름(키)를 기준으로 프로퍼티를 추출하여 리스트에 할당한다. 1234567891011121314//ES5var name = { firstname: 'hyunho', lastname: 'lee' };var firstname = name.firstname;var lastname = name.lastname;console.log(firstname, lastname); // hyunho lee//ES6var name = { firstname: 'hyunho', lastname: 'lee' };var { firstname, lastname } = name;console.log(firstname, lastname); // hyunho lee 객체 디스트럭팅은 왼쪽에 할당 연산자, 오른쪽에 변수 리스트가 필요하고, 특정 필요한 프로퍼티 값만 추출할 수 있다.","link":"/2019/05/24/TIL-190524/"},{"title":"TIL-190525","text":"27일차 (0525) - JavascriptJavascript - What I learn… 클래스 클래스 (Class)1. 클래스 정의 (Class Definition)클래스는 클래스 이전에 참조할 수 없다. 그러나 호이스팅이 발생하는 것은 아니다. 클래스는 let, const 처럼 호이스팅이 보이지 않는다. 즉 일시적 사각지대(Temporal Dead Zone: TDZ)에 빠진다. 2. 인스턴스의 생성new 연산자와 같이 클래스 이름을 호출하면 클래스 인스턴스를 생성할 수 있다. 123class foo {}// Foo는 클래스 이름이 아니라 constructor(생성자)이다.const foo = new Foo(); 만약 new 연산자를 사용하지 않고 constructor를 호출하게 된다면, TypeError가 발생한다. 3. constructor인스턴스를 생성하기 위한 메소드이다. constructor로 인스턴스가 생성되면 동시에 클래스 필드의 생성과 초기화를 실행한다. 클래스 필드클래스 내부에 캡슐화된 변수를 말한다. 즉 데이터 맴버, 맴버 변수라고 부른다. 클래스 필드는 생성자 함수에서 this에 추가된 프로퍼티를 가르키며, 인스턴스, 정적 프로퍼티가 될수 있다. 12345678class Obj { constructor(item) { //constructor는 생략이 가능하다 this.item = item; }}let newItem = new Obj('pen');console.log(newItem); 클래스 내부에는 한개의 constructor만 존재할 수 있다. 만약 두개 이상이 존대 한다면. SyntaxError를 발생한다. 12345678class Foo {}const foo = new Foo();console.log(foo); // Foo {}// 프로퍼티 동적 할당 및 초기화foo.name = ['lee', 'hyun'];console.log(foo); // Foo { name: [ 'lee', 'hyun' ] } 4. 클래스 필드클래스 내부에서는 메소드만 선언할 수 있다. 만약 클래스 필드(맴버 변수)를 선언하면 문법 에러(SyntaxError)가 발생한다. 5. 호이스팅6. getter, setter6.1 getter6.2 setter7. 정적 메소드8. 클래스 상속8.1 extends 키워드upper 클래스에서 lower 클래스로 상속을 할 때 정의 한다. 8.2 super 키워드부모의 클래스를 참조(reference)할 때 또는 부모의 클래스의 constructor를 호출할 때 사용. 8.3 static 메소드와 prototype 메소드의 상속","link":"/2019/05/25/TIL-190525/"},{"title":"TIL-190526","text":"28일차 (0526) - JavascriptJavascript - What I learn… 문서 객체 모델(DOM) 문서 객체 모델(Document Object Model)1. DOM (Document Object Model)2. DOM treeDocument믐 DOM tree에 진입점(entry point)이다. 3. DOM Query / Traversing (요소에의 접근)3.1 하나의 요소 노드 선택(DOM Query)3.2 여러 개의 요소 노드 선택(DOM Query)3.3 DOM Traversing (탐색)4. DOM Manipulation (조작)4.1 텍스트 노드에의 접근/수정4.2 어트리뷰트 노드에의 접근/수정4.3 HTML 콘텐츠 조작(Manipulation)4.4 DOM 조작 방식4.5 insertAdjacentHTML()4.6 innerHTML vs. DOM 조작 방식 vs. insertAdjacentHTML()5. style","link":"/2019/05/26/TIL-190526/"},{"title":"TIL-190527","text":"29일차 (0527) - JavascriptJavascript - What I learn… 동기식 처리 모델 vs 비동기식 처리 모델 동기식 처리 모델 vs 비동기식 처리 모델(Asynchronous processing model)","link":"/2019/05/27/TIL-190527/"},{"title":"TIL-190529","text":"31일차 (0529) - JavascriptJavascript - What I learn… 비동기식 처리 모델과 Ajax 비동기식 처리 모델과 Ajax Web server요청을 받으면, HTML, CSS, Javascript, Jpg, SVG, XML을 서버로 부터 제공한다. Application server정적파일을 제공할 수 있는 기능, RESR API를 처리할 수 있다. Database server 1. Ajax (Asynchronous JavaScript and XML)Ajax (Asynchronous JavaScript and XML)브라우저에 페이지를 요청하면 서버와 통신하여 화면에 갱신이 발생하는 것을 말한다. 즉 자바스크립트를 이용하여 비동기적으로 서버와 브라우저 간에 데이터 교환 통신 방법을 의미한다.(Request를 보내고 Responsive를 받는다. ) 서버로 부터 웹페이지 전체가 아닌 일부분만 갱신하는 방법으로 더 좋은 퍼포먼스를 기대할 수 있다. 데스크탑 에플리케이션과 유사한 퍼포먼스를 기대할 수 있다. (화면전환 안된다.) 2. JSON (JavaScript Object Notation)클라이언트와 서버 간에 데이터 교환 패턴, 데이터 포멧을 말한다. JSON은 XML 포멧보다 가볍고 가독성이 좋으며, 일반 텍스트 포멧보가 효과적인 데이터 구조화가 가능하다. [키는 반드시 큰따옴표를 사용해야한다 (작은 따옴표 사용불가)] 123456{ \"name\": \"Lee\", \"gender\": \"male\", \"age\": 20, \"alive\": true} 반드시 포멧을 준수해야 한다. JSON은 순수한 텍스트 포멧으로 구성된 규칙이 있는 데이터 구조이다.(자바스크립트 객체 리터럴과 매우 유사하다) = 문자열로만 통신한다.= 화면을 만들기 위해 사용하며, 화면 전체가 아닌 일부만 갱신하는 방식이다. 2.1 JSON.stringify객체를 JSON 포멧의 문자열로 변환하는 메소드이다. 2.2 JSON.parseJSON 데이터를 가진 문자열을 객체로 변환한다. 역직렬화(Deserializing)을 통해 서버에서 브라우저로 전송된 JSON 문자열 데이터를 객체화하는 방식으로 JSON.parse을 사용할 수 있다. 배열이 JSON 형식의 문자열이라면, JSON.parse를 통해 객체화할 수 있다.(배열의 요소가 객체인 경우 그 요소 또한 객체화 된다) 123456789101112131415161718192021var todos = [ {id: 1 content: 'music', completed: false}, {id: 2 content: 'work', completed: true}, {id: 3 content: 'math', completed: false},];var str = JSON.stringify(todos);console.log(typeof str, str);// string// [{\"id\":1,\"content\":\"HTML\",\"completed\":true},// {\"id\":2,\"content\":\"CSS\",\"completed\":true},{\"id\":3,// \"content\":\"JavaScript\",\"completed\":false}]var pars = JSON.parse(str);console.log(typeof pars, pars);// (3) [{…}, {…}, {…}]// 0: {id: 1, content: \"HTML\", completed: true}//1: {id: 2, content: \"CSS\", completed: true}//2: {id: 3, content: \"JavaScript\", completed: false}//length: 3//__proto__: Array(0) 3. XMLHttpRequest서버가 브라우저의 요청에 대해 응답을 반환하면 XMLHttpRequest 객체를 이용해 Ajax 요청을 생성하고 전송한다. 3.1 Ajax requestxhr = XMLHttpRequest 요청을한 서버에서만 리스폰을 받을수 있다 == 리스폰을 받은 곳에만 요청을 할 수 있다. JSON.p(interview )CORS 3.1.1 XMLHttpRequest.openXMLHttpRequest 객체의 인스턴스를 생성하고 XMLHttpRequest.open 메소드를 사용하여 서버에 요청을 준비한다. 사용법 1XMLHttpRequest.open(method, url[, async]) 매개변수 설명 method HTTP method (“GET”, “POST”, “PUT”, “DELETE” 등) url 요청을 보낼 URL async 비동기 조작 여부. 옵션으로 default는 true이며 비동기 방식으로 동작한다. 3.1.2 XMLHttpRequest.send일반적으로 GET, POST의 메소드에 따라 MLHttpRequest.send 메소드로 준비된 요청을 서버에 전달한다. GET 메소드, URL의 일부분인 쿼리 문자열(Query String)로 데이터를 서버로 전송POST 메소드, 데이터(페이로드)를 Request body에 담아 전송한다. 페이로드 = 실제 중요한 데이터 12345xhr.send(null);// xhr.send('string');// xhr.send(new Blob()); // 파일 업로드와 같이 바이너리 컨텐트를 보내는 방법// xhr.send({ form: 'data' }); // 폼데이터 넘기기// xhr.send(document); // 객체로 넘기기 3.1.3 XMLHttpRequest.setRequestHeaderHTTP Request Header의 값을 설정한다. 이 메소드는 반드시 XMLHttpRequest.open 메소드 호출 이후에 호출해야 한다. contents-typerequest body에 담아 전송할 데이터의 MINE-type의 정보를 표헌한다. 타입 서브타입 text 타입 text/plain, text/html, text/css, text/javascript Application 타입 application/json, application/x-www-form-urlencode File을 업로드하기 위한 타입 multipart/formed-data 123456789// json으로 전송하는 경우xhr.open('POST', '/users');// 클라이언트가 서버로 전송할 데이터의 MIME-type 지정: jsonxhr.setRequestHeader('Content-type', 'application/json'); // 정식const data = { id: 3, title: 'JavaScript', author: 'Park', price: 5000 };xhr.send(JSON.stringify(data)); Accept데이터 요청 방식, 3.2 Ajax response4. Web Server클라이언트 사이드로 부터 HTTP 요청을 받아들이고, HTML 문서(웹 페이지)를 반환하는 프로그램이다. 웹 서버 생성 방법 (Node.js 설치후, Express로 웹서버를 생성한다) 12345678//데스크탑에 webserver-express 폴더가 생성된다.$ cd ~/Desktop$ git clone https://github.com/ungmo2/webserver-express.git$ cd webserver-express// install express$ npm install// create public folder$ mkdir public 5. Ajax 예제5.1 Load HTML5.2 Load JSON5.3 Load JSONPCORS 처리","link":"/2019/05/29/TIL-190529/"},{"title":"TIL-190530","text":"32일차 (0530) - JavascriptJavascript - What I learn… REST(Representational State Transfer) REST(Representational State Transfer) API= Representational State Transfer의 약자로 HTTP URI (Representational State Transfer)통해 자원(Resource)을 명사로 명시하고 Method(Post, Get, Put, Delete)를 구분하여 해당 자원에 대해 CRUD Operation을 적용하고, 상태를 주고 받는 모든 것을 의미한다. CRUDCreate(post)Read(get)Update(put,patch)Delete(delete) 자원에 아름을 명사로 구분하여 해당 자원의 상태 정보를 주고 받는 모든것 기존 웹의 기술과 HTTP 프로토콜을 그대로 활용할 수 있는 아키택처 데이터를 요청할 때 이름을 명확하게 작성하자.(명사형) 1. REST API 중심 규칙2. HTTP Method Method Action 역할 GET index/retrieve 모든/특정 리소스를 조회 POST (페이로드 필) create 리소스를 생성 PUT (페이로드 필) update 리소스를 갱신 PATCH (페이로드 필) update all 리소스를 일괄 갱신 DELETE (상황에 따라) delete 리소스를 삭제 3. REST API의 구성4. REST API의 Example4.1 json-server4.2 GET4.3 POST4.4 PUT=데이터 리소스를 전체를 갱신한다. 4.4.1 PATCH= 데이터 리소스를 데이터를 한개만 갱신한다 4.5 DELETE","link":"/2019/05/30/TIL-190530/"},{"title":"TIL-190531","text":"33일차 (0531) - Javascript 프로미스 (Promise) Javascript - What I learn… 1. 프로미스란?2. 콜백 패턴의 단점2.1 콜백 헬2.2 에러 처리의 한계3. 프로미스의 생성4. 프로미스의 후속 처리 메소드5. 프로미스의 에러 처리6. 프로미스 체이닝7. 프로미스의 정적 메소드7.1 Promise.resolve/Promise.reject7.2 Promise.all7.3 Promise.race","link":"/2019/05/31/TIL-190531/"},{"title":"HOW TO START GIT COOPERATIVE WORK.","text":"Repository 만들기 깃을 가입합니다. 오른쪽 상단에서 “Your Profile”을 클릭하면 자신의 계정에 프로필로 들어갑니다. 자신에 프로필 페이지에서 다양한 세팅을 할 수 있지만 프로젝트 진행을 위해 “Repositories”에 들어갑니다. Repositories”에서 초록색 UI “NEW”을 눌러 새로운 Repositories”을 생성해줍니다. 가장먼저 자신에 유저 아이디를 볼 수 있습니다.a. 옆에 Repositories”, 프로젝트 이름을 입력해줍니다.b. 초록색 체크 박스가 나타나면, 사용이 가능한 이름입니다.c. 가장 먼저, 프로젝트의 설명과 제작 방식 등을 기입 할 수 있는 “README.md” 파일을 만들기 위해 “Initialize this repository with a README”을 선택해줍니다.d. 추가로 “Description”에 프로젝트에 간단한 설명을 넣어 줍니다. 성공적으로 “Repositories”을 생성하고 프로젝트를 시작할 준비가 되었습니다. ‘Repositories”을 들어가면 “README” 파일이 생성된 것을 볼 수 있습니다.","link":"/2019/04/18/git-협업-프로젝트-시작하기/"},{"title":"TIL-190501","text":"3일차 (0501) - JavascriptJavascript - What I learn… 데이터 타입 데이터 타입1. 데이터 타입이란 무엇인가? 왜 필요한가?데이터 타입(Data type = 타입)은 값의 종류를 말한다. 자바스크립트는 모든 값을 데이터 값을 가지고 있다. 1.1 데이터 타입에 의한 메모리 공간의 확보프로그래밍을 하기 위해 사용되는 메모리는 저장하고 참조할 수 있어야 한다. 우선 적으로 몇 byte의 메모리 공간을 저장할 수 있는지 알아야 확보해야 할 메모리 크기를 결정할 수 있다. 1.2 데이터 타입에 의한 값의 해석데이터 타입은 메모리 공간의 주소를 찾아가야 하기 때문에 매우 중요하다. 그렇지만 왜 중요할까? 값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정하기 위해 값을 참조할 때 한번에 읽어 들어야 할 메모리 공간의 크기를 결정하기 위해 메모리에서 읽어 들인 2진수를 어떻게 해석할 지를 결정하기 위해 2. 값 값(value)은 더이상 평가할 수 없는 하나의 표현식이다. 즉 새로운 값에 정의가 명확해진 것으로 하나의 값으로 메모리 공간 자체를 말한다. 3. 값의 생성값은 리터럴 표기법을 사용하며, 다양한 방법으로 표현, 생성할 수 있다. 리터럴(Literal)소스코드 안에 리터럴 표기법으로 생성한 직접 만들어 낸 고정된 값 자체를 말한다. 3.1.1 리터럴 표기법을 통한 값의 생성리터럴 표기법(Literal notation)은 값을 생성하는 가장 기본적인 방식으로 의미를 가지고 있는 값에 최소 단위이다. 다양한 타입 값(숫자, 문자열, 불리언, null, undefined, 객체, 배열, 함수, 정규 표현식 등)을 가지고 있으며 자유롭게 생성할 수 있다. // 정수 리터럴 100 // 부동 소숫점 리터럴 10.5 // 2진수 리터럴(0b로 시작) 0b01000001 // 8진수 리터럴(ES6에서 도입. 0o로 시작) 0o101 // 16진수 리터럴(ES6에서 도입. 0x로 시작) 0x41 // 문자열 리터럴 'Hello' \"World\" // 불리언 리터럴 true false // null 리터럴 null // undefined 리터럴 undefined // 객체 리터럴 { name: 'Lee', gender: 'male' } // 배열 리터럴 [ 1, 2, 3 ] // 함수 리터럴 function() {} // 정규표현식 리터럴 /ab+c/ 3.2.2 값과 리터럴의 관계 var score = 100; 더 이상 평가할 수 없는 리터럴이자 변수에 할당할 수 있는 값이면서 리터럴에 조건에 충족한다. var scroe = 50 + 50; 연산자를 이용해 값을 생성하는 문을 표현식(expression)이라고 한다. 리터럴 값으로 가장 기본적으로 최소 값을 가지고 있다. 3.2 표현식표현식(expression)은 리터럴, 식별자(변수명, 함수명 등), 연산자, 함수 호출등의 조합을 말한다. 즉 하나의 값으로 평가될 수 있는 문(statement)이다. // 리터럴 표현식 10 'Hello' // 식별자 표현식 sum person.name arr[1] // 연산자 표현식 10 + 20 sum = 10 sum !== 10 // 함수/메소드 호출 표현식 square() person.getName() 4. 데이터 타입의 분류ES6 기준 자바스트립트는 7개읠 데이터 타입을 제공하며 1개의 객체 타입을 포함한다. 원시타입 (primitive type) 숫자 (number) 타입: 숫자(정수, 실수) 문자영 (string) 타입: 문자열 불리언 (bloolaam) 타입: 논이적 참 / 거짓 undefined 타입: 선언은 되었지만 값이 없는 변수에 암묵적으로 할당되는 값 null 타입: 값이 없다는 것을 의도적으로 명시할 값 symbol 타입: ES6에서 새롭게 추가된 7번째 타입 객체 타입 (object / reference type): 객제, 함수, 배열등 데이터는 보기에 같아도 목적이 다르며, 저장되는 메모리에 크기도 다를수 있다. 5. 숫자 타입ECMAScript 따라 숫자 타입은 64비트 부동소수점 형식(double-precision 64-bit floting-point: -(2^52 -1)~2^53 -1 사이의 숫자 값)을 따른다. 즉 실수로 표현하기 때문에 정수 표현이 어렵다. 정수로 되고, 정수로 표시 한다고 해도, 자바스크립트는 그 숫자를 실수로 받아들여서 연산시 정확한 값을 도출하기 어렵다. 숫자 타입은 3가지 특별한 값을 표현이 가능하다 Infinity: 양의 무한대 -Infinity: 음의 무한대 NaN: 산술 연산 불가 (Not-a-Number)– 자바스크립트는 대소문을 구별 하므로 에러에 주의한다. 6. 문자열 타입문자열(string) 타입은 텍스트 데이터를 나타내는데 사용된다. 문자열을 생성할 때는 작은 따옴표(‘ ‘), 큰 따옴표(“ “), 또는 배틱 ()안에 문자열을 넣는다. 자바스크립트에서는 일반적으로 작은 따옴표를 쓰는 것을 권장하며, 암묵적인 룰로 작용하고 있다. 자바스크립트에서 문자열은 원시 타입으로 변경이 불간능한 값(immutable value)이다. 즉 문자열이 한번 생성되면, 그 문자열을 변경할 수 없다. 6.1 템플릿 리터럴ES6 부터 템플릿 리터럴(Template literal)이라고 불리는 문자열이 도입되었다. 템플릿 리터럴은 작은 따옴표와 큰 따옴표를 혼용할 수 있는 방식으로 만약 두 따옴표가 한 문장에 있다면 백틱을 사용하여 묶을수 있다. 또한 일반적인 문자열과 달리 문자열 사이에 공백이 적용되며, 줄 바꿈은 허용되지 않는다. 단 백슬래시()로 이스케이프 시퀀스(Escape Sequence)를 사용할 수 있다. 문자열은 + # + 문자열 연산자를 통해 연결할 수 있다. var first = 'hyun-ho'; var last = 'Lee'; // ES5: 문자열 연결 console.log('My name is ' + first + ' ' + last + '.'); 하지만 탬플릿 리터럴은 연산자를 사용하지 않아도 문자열을 삽입할 수 있는대 이를 문자열 인폴레이션(String Interpolation)이라 한다. var first = 'hyun-ho'; var last = 'Lee'; // ES6: 문자열 연결 console.log('My name is ${first} ${last}.'); 문자열 인터폴레이션은 \\${expression}으로 표현식을 감싼다. 단 이때 문자열을 타입으로 변환된다. 7. 불리언 타입불리언(boolean)타입의 값은 논리적 참(true)와 거짓(false)으로 나눈다. 주로 프로그램에 흐름을 제어하는 조전문에 사용된다. 8. Undefined 타입선언 이후 명시적으로 값을 할당하지 않는 변수는 자바스트립트 엔진의 의해 암묵적으로 초기화 되는데 이때 값이 undefined 값을 가진다. 즉 값이 할당이 되지 않은 변수에 접근하면 undefined가 반환된다. 9. Null 타입10. Symbol 타입11. 객체 타입12. 동적 타이핑 typeof 연산자변수에 할당된 값의 데이터 타입을 반환한다. 12.1 동적 타입 언어와 정적 타입 언어정적 타입(Static/Strong type)언어는 변수를 선언할 때 데이터 타입을 사전에 선언해야 한다. 이를 명시적 타입 선언(Explicit type declaration)이라 한다 정적 타입 언어는 변수 타입을 변경할 수 없으며, 선언한 타입에 값만 할당할 수 있다. 타입이 맞지 않으면 실행 차제를 막기 때문에 안정적으로 코드를 구현하고 런타임 에러를 줄일수 있다. 정적 타입 언어는 C, C++, java, Kotlin, Go, Haskell, Rust, Scala 등이 있다. 12.2 동적 타입 언어와 변수동적 타입(Dynamic typing)언어는 변수를 선언할 때 데이터 타입을 자유롭게 할당할 수 있다. 동적 타입에 언어는 변수 선언이 아닌 할당에 의해 결정된다.즉 재할당에 의해 변수의 타입은 언제든지 변경할 수 있다. 그렇지만 복잡한 프로그램에서 동적 변화 데이터는 추적이 어렵고, 의도치 않은 충동을 만들어 낼수 있다. 또한 데이터 저장 값을 확인하기 전까지 값을 확신할 수 없다. 결국 동적 타입 언어는 유연성(flexibility)은 높지만 신뢰성(reliabiity)은 떨어진다 주의사항 변수의 사용을 적그적으로 줄인다. 변수의 개수가 많으면 오류가 발생할 확률은 높아진다. 전역 변수는 사용하지 않는다. 변수의 생명주기를 최대한 짧게 만든다. 변수보다는 상수를 사용해 값을 변경을 억제한다. 변수명은 변수의 존재 이유를 파악할 수 있도록 명명한다. 동적 타입 언어는 Python, PHP, Rudy, Lisp, Perl","link":"/2019/05/01/TIL-190501/"},{"title":"TIL-190430","text":"2일차 (0430) - JavascriptJavascript - What I learn… 변수 변수 1. 변수란 무엇인가? 왜 필요한가?변수는 데이터를 관리하기 위한 핵심 개념이다. 1var a = 10 + 20; CPU가 연산을 하기 위해선 연산자의 좌변과 우변에 숫자 값을 기억해야 한다. 이때 컴퓨터는 메모리를 사용한다. 메모리데이터를 저장할 수 있는 메모리 셀(memory cell)들의 집합체이다. 각 메모리는 1byte(8bit)에 크기를 가지고 있고 데이터를 저장(write), 읽기(read)가 가능하다. 컴퓨터는 모든 데이터(숫자, 텍스트, 이미지, 동영상)를 2진수로 처리한다.메모리는 고유 주소로 표시가 되고, 이 공간의 위치를 0부터 메모리 크기 만큼에 정수로 표시한다.4,294,967,295(0x00000000 ~ 0xFFFFFFFF) = 4GB 숫자 값 10, 20은 메모리의 임시 주소에 저장되고 이 값으로 CPU 연산을 수행한다. 결과 값 30또한 임시 주소에 저장된다. (표기는 10진법이지만, 실제 메모리 상에는 2진수로 저장 된다) 그렇지만 이렇게 저장된 30의 결과는 재사용이 불가능하다. 이러한 데이터를 재 사용 하기 위해 변수를 사용해야 한다. 변수(Variable)하나의 값을 저장할 수 있는 메모리 공간에 붙인 이름 또는 메모리 공간 자체를 말한다. 개발자는 메모리 주소를 직접 다루지 않아도 변수 값을 할당(assignment 대입, 저장)하거나 참조(reference)할 수 있고 값을 변경할 수도 있다. var result = 10 + 20; “result” 라는 변수값은 메모리 주소에 저장한다. 이러한 방식을 할당(assignment 대입, 저장)이라고 하고, 변수를 읽는 행동을 참조(reference)라고 한다. 식별자(Identifier)변수명 보다 상위에 개념으로 변수, 함수, 클래스 등 이름을 구별할 수 있는 이름이 모두 포함 된다. 즉 사람이 이해할 수 있는 고유한 이름을 가리키는 값이다. 식별자 즉 변수명은 개발자을 위한 문서이다. 저장된 값의 의미를 명확히 함으로서 가독성을 높이고 이해하기 쉽게 만들어 협업과 코드에 품질 향상에 도움을 준다. 2. 변수 선언 (Variable Declaration)변수명을 자바스크립트 엔진에 존재를 알려 관리할 수 있도록 하는것. 변수를 사용하기 위해선 반드시 선언을 통해야 한다.변수를 선언 할 때는 var, let, const의 키워드로 사용한다. ES6가 도입 되기 이전에는 오직 var만 사용이 가능했지만, var의 블록 레벨 스코프(Block-level-scope) 단점으로 let, const이 ES6에서 추가 되었다. var score; Score는 뒤에 오는 변수명으로 새로운 변수를 선언 할 것을 지시하는 키워드이다. 키워드(keyword)키워드는 자바스크립 엔진이 수행할 동작을 규정한 일종의 명령어이다. 키워드를 만나면 자신이 수행해야 할 약속된 동작을 수행한다. 키워드가 실행되면 자바스크립트 엔진은 새로운 변수를 선언한다. 리팩토링외부 동작을 바꾸지 않으면서 내부 구조를 개선하는 방법. 즉 코드를 보다 이해하기 쉽도록 수정하는 행동 변수명을 선언하고 값을 저장할 메모리 공간을 확보한다. “undefined”는 빈 공간이 아니라 암묵적으로 값이 할당되어 초기화된다. *undefined 자바스크립트가 제공하는 원시 타입 값 (peimitive value) 자바스크립트 엔진 변수 선언 단계 선언 단계(Declaration Phase): 변수명 등록 및 자바스크립트 엔진에 변수에 존재를 알림 *변수명 등록변수명 및 모든 식별자는 실행 컨텍스트(Execution Context)의 렉시컬 환경(Lexical Environment)에 등록된다. 실행이 가능한 코드는 평가하고 실행에 필요한 환경을 관리 한다. 초기화 단계(Initialization Phase): 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 undefined를 할당. *Garage Value이전에 다른 애플리케이션이 사용했던 값이 남아있거나, 메모리에 공간을 확보한 후 다음 값을 할당하지 않고 참조하면 나오는 값 3. 변수 선언의 실행 시점과 변수 호이스팅&lt;pre&gt; Console.log(score); Var score: &lt;/pre&gt; 자바스크립트는 위에서 한 줄씩 순차적으로 실행되는 방식으로 참조가 변수 선언보다 앞에 있을 경우 참조 에러(ReferenceError)가 발생한다. 여기서 에러는 undefined로 출력 된다. 자바스크립트는 인터프리터 언어로서 동적 기능을 살리면서 실행 속도가 느리다는 단점을 극복한다. AST모든 언어는 소스코드는 단순히 문자열로 구성되어 있다. 따라서 문법적 의미와 구조를 갖는 자료 구조인 AST (Abstract Syntax Tree, 추상적 구문 트리)를 생성한다. AST는 바이트 코드 또는 머신 코드를 생성하여 실행한다. 변수 호이스팅(Variable Hoisting)이란변수 선언문이 코드의 선두로 끌어 올려진 것 처럼 동작하는 자바스크립트의 특징 4. 값의 할당변수에 갑을 할당 할 때는 할당 연산자(=)를 사용한다. 할당 연산잔는 우변의 값을 좌변에 변수로 할당한다. 변수에 값을 할당할 때는 이전 값 undefined가 저장되어 있던 메모리 공간을 지우고 그 메모리 공간에 할당 값 80을 새롭게 저장하는 것이 아니라 새로운 메모리 공간을 확보하고 그 메모리 공간에 할당 값 80을 저장하는 것에 주의하자. 5. 값의 재할당Var을 사용하여 선언한 변수 값을 재할당 할 수 있다. 재할당이란 현재 변수가 저장하고 있는 값을 버리고 새로운 값을 저장하는 것이다. 만약 재할당을 할 수 없어서 변수에 저장된 값을 변경 할 수 없다면, 그것을 상수(Constant)라 부른다. 상수는 한번 정해지면 값이 변하지 않는다. 즉 상수는 단 한번만 할당이 가능하다. 만약 초기에 지정한 값을 새로운 값으로 변경하고, 변경 값이 저장 후 이전 값을 undefined로 교체한다. 이전 값이 더 이상 필요하지 않은 값이 된다면 가비지 컬렉터 (Garbage Collator)에 의해 자동으로 메모리에서 해제된다. 매니지드 언어(Unmanaged Language)C 언어와 같이 개발자가 명시적으로 메모리를 할당, 해제하기 위해 malloc(), free()와 같은 저수준 (low-level)메모리 관리 기능을 제공한다. 메모리 관리를 개발가 주도 하므로 최적에 퍼포먼스를 확보할 수 있지만 반대로 많은 오류를 만들어 낸다. 매니지드 언어(Managed Language)자바스크립트와 같이 메모리를 할당, 해제가 제한되며, 모든 기능을 언어 차원에관리된다. 또한 가비지 컬렉터 (Garbage Collator)가 메모리 해제수행하며 개발자는 어떠한 직접적인 제어를 할 수 없다. 그러나 일정한 생산성확보하고 메모리 관리에 신경을 쓰지 않아도 된다는 장점을 가지고 있다. 8. 식별자 네이밍 규칙 식별자는 특수문자를 제외한 문자, 숫자, underscore( _ ), 달러 기호(\\$)를 포함할 수 있다. 단, 식별자는 특수문자를 제외한 문자, underscore( _ ), 달러 기호(\\$)로 시작해야 한다. 숫자로 시작하는 것은 허용하지 않는다. 예약어는 식별자로 사용할 수 없다. 예약어 = keywordawait break case catch class const continue debugger default delete do else enum export extends false finally for function if implements import in Instanceof interface let new null package private protected public return super static Switch this throw true try typeof var void while with yield* 일반적으로 변수와 함수의 이름에는 카멜 케이스를 사용하고 생성자 함수, 클래스의 이름에는 파스칼 케이스를 사용한다.코드 전체의 가독성을 높이려면 네이밍 컨벤션을 따르는 것이 유리하다.","link":"/2019/04/30/TIL-190430/"},{"title":"TIL-190429","text":"1일차 (0429) - JavascriptJavascript - What I learn… 프론트엔트 개발자란? 자바스크립트란? 자바스크립트 개발 환경과 실행 방법 프론트엔드 개발자란? 서버에서 데이터를 가져와서, 가공, 유저가 원하는 서비스를 만드는 사람. 즉 서버와 사용자 사이에 중간자 역할로 유저와 소통이 가능하고, 사용성을 구현한다. 애플리케이션을 사용하는 사람(유저)이 애플리케이션과 소통하기 위해 UI 을 사용하기 좋게 구현한다. UI상태 정보를 서버로 전송하기도 하고 서버의 데이터를 가져와서 UI에 표시하기도 한다. 디자이너, 백앤드 개발자와 협업 1. Computational Thinking프로그래밍은 원하는 명령을 컴퓨터에 전달하는 일종에 커뮤니케이션 방식이다. 즉 프로그래밍 언어는 프로그래머가 컴퓨터에게 명령을 전달하기 위한 언어의 집합이다. 프로그램은 간혹 문제 해결 능력을 요구하지만, 프로그래밍 차체는 알고리즘(문제 해결)과는 다른 영역이다. 다만 문제를 해결 방안을 고려할 때 필요한 것이 Computational Thinking이다 컴퓨터에 명령을 할 때는 논리적, 수학적 사고가 필요하게 되며 해결 과제를 작은 단위로 분해하고 패턴화해서 추출해야 더욱 효과적으로 프로그래밍을 할 수 있다. 2. 프로그래밍 언어컴퓨터가 사용하는 언어로 변환해주는 방식을 컴파일러 (Compiler) 혹은 인터프리터(Interpreter)라고 한다. 여기서 언어란 자신의 생각을 상대에게 전달하는 방법으로 언어 공동체 내에서 이해될 수 있는 말의 집합이다. 프로그래밍 언어는 Syntax(구문)와 Semantics(의미)의 조합으로 표현된다. 3. Syntax &amp; Semantics프로그램 언어를 배우기 위해선 일반적으로 문법을 우선적으로 공부를 해야한다. 문장에 정확한 이해와 문법에 맞는 문장을 구성하는 것은 물론 의미(Semantics)를 가지고 있어야 언어의 역할을 수행할 수 있다. 프로그래밍 언어는 문법이 아니라 문맥에 따라 의미를 파악하기 때문에 해결해야 하는 문제를 명확히 파악하고 요구사항이 실현(문제 해결)되어야 한다. 대부분의 프로그래밍 언어는 변수와 값, 키워드, 연산자, 표현식(Expression), 조건문과 반복문에 의한 흐름 제어(Control flow), 문(Statement), 문의 집합인 함수 그리고 객체, 배열 등의 자료구조와 같은 문법을 제공한다. 자바스크립트란? 1. 자바스크립트의 탄생1995년 90%의 시장 점유율로 웹 브라우저 시장을 지배하던 넷스케이프 커뮤니케이션즈(Netscape Communications)는 동적인 HTML 구현하기 위해 새로운 프로그래밍 언어를 도입하기로 결정했다. 이 당시 브랜던 아이크 (Brendan Eich)로 부터 개발된 언어가 자바스크립트이다. 자바스크립트는 1996년 Netscape Navigator 2에 탑재되었고 “Mocha”로 이름이 바뀌었지만 그해 9월 “LiveScript”로 이름이 변경되었고, 12월 최종적으로 JavaScript로 바뀌었다. 2. 자바스크립트의 파편화와 표준화1996년 마이크로소프트는 자바스크립트 버전에 JScript를 IE 3.0에 탑재했다. 그렇지만 표준화 되지 못하고 브라우저에 따라 웹 페이지가 정상 동작하지 않는 크로스 브라우징 이슈가 발생하기 시작했다. 크로스 브라우징브라우저 버전에 따라 웹 페이지가 정상적으로 동작하지 않거나 다르게 해석되어 화면에 에러가 발생하는 일. 따라서 개발자는 다양한 브라우저에서 동작하는 웹 페이지를 개발 할 수 있어야 한다. 이에 따라 모든 브라우저에서 동일하게 동작하는 표준이 필요하게 되었고, 이를 위해 1996년 넷스케이프 커뮨니케이션즈는 시스템 표준을 관리하는 비영리 표준화 기구인 ECMS 인터내셔널에 자바스크립트의 표준화를 요청하였다. 3. 자바스크립트 성정의 역사 초창기에 자바스크립트는 웹 페이지에 보조 역할로 HTML/CSS를 기본적으로 렌더링 해주는 수준이었다. 렌더링(Rendering)HTML과 CSS로 표현된 데이터를 해석하여 시각적으로 브라우저에 표현하는 것을 말한다. 1999년, 자바스크립트를 이용해서 비동기적(Asynchronous)으로 서버와 브라우저가 데이터를 통신할 수 있는 Ajax (Asynchronous JavaScript and XML)가 XMLHttpRequest라는 이름으로 등장했다. Ajax는 웹 페이지의 변경이 필요 없는 부분은 다시 렌더링하지 않고, 서버로 부터 필요한 데이터만을 전송 받아 변경이 필요한 부분만 렌더링이 가능했다. 이전에 불필요한 데이터를 낭비하는 일과 렌더링 속도를 획기적으로 개선했다. 2006년, jQuery의 등장으로 DOM(Document Object Model)을 보다 쉽게 제어가 가능하고 크로스브라우징 문제가 다수 해결 되었다. 2008년, Google Maps를 통해 가능성이 확인된 자바스크립트로 더욱 빠른 자바스크립트 엔진이 필요하게 되었고, V8 자바스크립트 엔진은 이러한 요구 사항에 맞게 빠른 성능을 보여 주었다. V8엔진은 데스크톱 애플리케이션과 유사한 사용자 경험(UX)을 제공할 수 있는 웹 애플리케이션 개발 언어로 정착 되었다. 또한 웹 서버에서 동작되던 기능이 클라이언트(브라우저)로 이동하였다. 2009년, 브라우저에서만 동작하던 자바스크립트를 브라우저 이외에 환경에서 동작할 수 있는 Node.js의 등장으로 자바스크립트는 웹 브라우저를 벗어난 서버 사이드 애플리케이션 개발에도 사용되는 범용 언어가 되었다. 덕분에 프론트엔트 및 백엔트 영역까지 커버할 수 있는 언어가 되었다. 4. JavaScript와 ECMAScript 자바스크립트는 일반적으로 프로그래밍 언어의 Core를 이루는 ECMAScript와 브라우저가 지원하는 클라이언트 사이드 Web API를 포함하는 개념이다. 자바스크립트 = ES + Web API ECMA란?정보 통신에 대한 표준을 제정하는 비영리 표준화 기구이다. 대표적으로 CD롬 볼륨, 파일 구조, C# 언어 규격, JSON포맷 등 일부 통신 기술에 대한 표준을 관리한다. 또한 ECMA-262 및 ECMA-402 스펙에서 표준화 되었다. JavaScript 란?정적인 HTML/CSS를 동적으로 변경해주는 언어이다. 객체(object)기반의 스크립트 언어로 웹 브라우저(클라이언트)에서 사용되고 Node.js 같은 프레임워크에서 사용할 수 있다.자바스크립트는 클라이언트 영역으로 사용자 파일에 접근을 불허한다. ECMAScript란? 자바스크립트를 이루는 코어(Core) 스크립트 언어로 웹환경에서만 호스트 되는 언어는 아니다. ECMAScript 환경이 구현되 있는 환경에 알맞는 확장성을 가지고 있다. 브라우저는 V8엔진으로 클라이언트 지원 방식으로 ECMAScript와 Web API로 구성되어있다 따라서 Node.js는 지원하지 않는다. Node.js는 V8엔진으로 ECMAScript, Node API로 구성되어있다. Node.js는 사용자 데이터에 접근이 가능하다. 5. 자바스크립트의 특징자바스크립트는 기존에 프로그래밍 언어에서 많은 영향을 받았다. 자바스크립트는 인터프리터 언어이다. 자바스크립트는 명령형(imperative), 함수형(functional), 프로토타입 기반(prototype-based) 객체지향 프로그래밍을 지원하는 멀티 패러다임 프로그래밍 언어이다. 자바스크립트 개발 환경과 실행 방법 컴파일러와 인터프리터의 비교 1. 자바스크립트 실행 환경모든 브라우저와 Node.js는 자바스크립트 엔진을 내장하고 있다. 따라서 두 환경 모두 자바스크립트를 실행할 수 있다. 그렇지만 브라우저와 Node.js는 목적이 다르다. 브라우저는 클라이언트 사이드 환경에 특화되어 Web API (Document Object Model)을 제공한다. HTML, CSS, 자바스크립트를 실행하여 웹 페이지를 화면에 렌더링하는 것이 주 목표이다.= ECMAScript, DOM, BOM, XMLHttpRequest, Fetch, requestAnimationFrame, SVG, Web Storage, Web Component, Web worker을 지원한다 Node.js는 언어가 아닌 서버 사이드 환경을 위해 제공하는 기능이다, Web API(DOM API)을 제공하지 않는다. 또한 Node.js에서는 파일을 생성하고 수정할 수 있는 File 시스템을 기본 제공한다.= ECMASscript, Node.js 만 지원한다. 클라이언트 사이드인 브라우저에서 파일을 생성, 제거를 할 수 있다면 악성 코드에 노출이 쉽기 때문에 보안상 이를 금지하고 있다. 2. 웹 브라우저2.1 웹 브라우저는 어떻게 동작하는가?구글에 v8 엔진으로 빌드 된 런타임 (Runtime Environment)인 Node.js의 등장으로 자바스크립트는 범용 개발 언어가 되었다. 자바스크립트는 클라이언트 사이드로서 웹 브라우저 환경에서 주로 동작한다. 브라우저는 기본적으로 요청(Request), 응답(Response)을 기본 동작으로 웹 상에 표시된다. 응답을 받을 때 HTML, CSS를 렌더링 엔진을 통해 파싱(Parsing)되어 DOM, CSSOM 트리로 변환 한다. 웹 페이지를 최종 적으로DOM, CSSOM 을 결합하여 Render Tree을 생성후 웹페이지에 표시한다. 그러나 자바스크립트를 포함한 웹 페이지는 자바스크립트 엔진이 따로 처리하기 때문에 HTML/CSS 가 파싱되는 중간에 자바스크립트가 로드 된다면. HTML/CSS을 중단하고 자바스크립트를 먼저 로드 및 파싱을 끝내고 다시 HTML/CSS 파싱을 시작한다. 이를 보완하기 위해서 async/defer를 사용하기도 하지만 주로 바디 가장 밑에 스크립트 태그로 붙이는 경우가 가장 일반적이다. 1&lt;script async src=\"test.js\"&gt;&lt;/script&gt; Async스크립트는 다운로드 완료후 실행이된다. 웹 파싱과 외부 스크립트 파일 다운로드가 동시에 진행된다. 그렇지만 IE 9 이하 버전은 지원 하지 않는다. 1&lt;script defer src=\"test.js\"&gt;&lt;/script&gt; defer스크립트는 웹 파싱 완료후 실행된다. 웹 파싱과 외부 스크립트 파일 다운로드가 동시에 진행된다. 그렇지만 IE 9 이하 버전은 지원 하지 않는다. 자바스크립트는 v8 엔진으로 토큰나이징(tokenizing), 파싱(parsing)을 거쳐 AST(Abstract Syntax Tree)를 생성한다. 토크나이징(Tokenizing)문자열인 코드를 어휘 분석(Lexical analysis)하여 코드의 최소 단위인 토큰(Token)들로 분리한다. 이런 과정을 토크나이징 혹은 렉싱(Lexing)이라고 부른다 파싱 (Parsing)토크나이징된 집합 구문을 분석(Syntactic analysis)하여 AST(Abstract Syntax Tree, 추상적 구문 트리)를 생성한다. AST는 문법적 의미를 가진 자료구조 이다. 코드 실행AST가 바이트 코드생성기를 통해 인터프리터로 실행되는 과정을 통칭한다. AST(Abstract Syntax Tree 추상적 구문 트리) 2.2 개발자 도구2.3 콘솔2.4 HTML 에 포함된 자바스크립트를 웹 브라우저에서 실행2.5 디버깅3. Node.js3.1 Node.js와 npm 소개3.2 Node.js 설치3.3 Node.js REPL4. 비주얼 스튜디오 코드4.1 비주얼 스튜디오 코드 설치4.2 내장 터미널4.3 Code Runner 확장 프러그인4.4 Live Server 확장 플러그인","link":"/2019/04/29/TIL-190429/"},{"title":"TIL-190503","text":"5일차 (0503) - JavascriptJavascript - What I learn… 제어문 (if…else, switch, for, while, do…while, Break, Continue) 제어문 (Control flow statement)코드의 실행 순서를 인위적으로 제어할 수 있으며(가독성이 떨어지고 오류를 발생시킨다) 일반적으로 코드는 위에서 아래로 순차적으로 신행된다. 주어진 조건에 따라 코드를 실행하거나 반복 실행한다. 1. 블록문 (Block statement / Compound statement)0개 이상의 문을 중괄호({})로 묶은 것으로 블록(코드 블록)이며 이는 하나에 실행 단위를 갖는다. 즉 같이 실행된다는 뜻을 가지고 있다. 블록문은 단독으로 사용이 가능하지만, 제어문이나 함수 선언문에 주로 사용한다. 문의 끝에 세미 콜론(;)을 옵션으로 붙이는 것이 가능하다. 12345678910// 블록문 =&gt; 의미가 없는 블록문{ var a = 10; console.log(a);}// 제어문var a = 0;while (a &lt; 10) { x++;} 2. 조건문 (Conditional statement)조건식 (conditional expression)은 불리언 값으로 평가되고 그 결과에 따라 코드 블럭의 실행을 결정한다. 2.1. if…else 문참, 거짓에 따라 실행할 코드 블록을 결정하고 결과 값이 불리언이 아니라면 강제적으로 논리적 참과 거짓을 구별한다. 만약 조건을 추가하려면 else if 문을 사용한다 1234567if (조건식){ // 참이면 해당 라인 코드가 실행된다.} else if (조건식 2) { // 조건식 2가 참이면 실행된다.} else { // 거짓이면 해당 라인 코드가 실행된다.} (조건식) = 표현문이지만 참, 거짓으로 평가될 수 있는 조건문 =&gt; 비교연산) if, else는 2번 이상 사용이 불가능하지만 else if는 여러번 사용이 가능하다. 단 if문 안에 if는 사용이 가능하고, if가 끝난후 다음에 새로운 if문을 시작해야한다. 1234567891011121314151617181920212223242526272829var num = 2;var kind;//if문if (num &gt; 0){ kind = '양수'; //음수를 구별할 수 없다}if (num &lt; 0){ kind = '음수'; //양수를 구별할 수 없다}console.log(kind)//if..else문if (num &gt; 0){ kind = '양수'; //음수를 구별할 수 없다} else { kind = '음수': // 0은 음수가 안니다.}console.log(kind) //양수//if...else if문if (num &gt; 0){ kind = ' 양수';} else if (num &lt; 0){ kind = '음수';} else kind = '영';}console.log(kind) //양수 만약 코드 블록 안에 문이 하나라면 중괄호 생략이 가능하다. 12345678var num = 2;var kind;if (num &gt; 0) kind = \"양수\";else if (num &lt; 0) kind = \"음수\";else kind = \"제로\";console.log(kind); 또한 대부분 if else 문은 삼항 조건 연산자로 바꿔 쓸 수 있다. 1234567891011// x가 짝수이면 짝수, 홀수이면 홀수를 반환var x = 2;var result;if (x % 2) { // 2 % 2는 0이고 0은 false로 취급한다 result = \"홀수\";} else { result = \"짝수\";}console.log(result); 다른 방식의 삼항 조건 연산자 12345// x가 짝수이면 짝수를, 홀수 이면 홀수를 반환var x = 2;// 0은 falsevar result = x % 2 ? \"홀수\" : \"짝수\";console.log(result); 세가지 경우의 수 (양수, 음수, 제로) 1234var num = 2;// 0은 falsevar kind = num ? (num &gt; 0 ? \"양수\" : \"음수\") : \"영\"; if..else 문은 표현식이 아닌 문이다, 또한 값처럼 사용이 불가능하다. 삼항 조건 연산자는 값처럼 사용이 가능하다. 2.2. switch 문주어진 표현문을 평가하여 그 값과 일치하는 표현식을 갖는 case 문으로 실행 순서를 이동 시킨다. case을 의미하는 표현식이 끝난 후 콜론으로 마친다. 여기서 일치하는 표현식이 없다면 실행 순서는 default 문으로 이동한다 (default는 옵션으로 없다면 다음 case로 넘어간다). Switch는 조건이 많을때 사용한다. 12345678910switch (표현식) { case 표현식1: //switch 표현식 + 표현식1이 일치하면 실행 break; case 표현식2: //switch 표현식 + 표현식2이 일치하면 실행 break; default: //switch 표현식과 일치하는 case가 없다면 실행} switch 문은 표현식은 불리언 값보다 문자열, 숫자값인 경우가 많다. 즉 다양한 상황(case)에 따라 코드를 실행할 때 사용한다. 폴스루(fall through)모든 케이스에 문을 통과하여 마지막 default 문을 실행하기 때문에 나오는 결과. fall through를 막기위해 해당 case 마지막에 break 문을 넣어서 일치하는 값을 찾아 코드를 나오게 해줘야 한다. 3. 반복문 (Loop statment)주어진 조건에 결과가 참일 경우만 실행한다. 반복문은 조건이 거짓이 될때까지 무한 반복 된다(시스템, 메모리 에러가 경우 실행이 중지 될수 있다). 3.1 for 문for (변수 선언 또는 할당; 조건식; 증감식) {실행 구문} for문의 구조 및 실행 순서 123for (var i = 0; i &lt; 2; i++) { console.log(i);} var i = 0 으로 i 값을 선언하고, 1번만 실행된다. 조건식으로 i 값을 평가한다. i는 0이므로 true. (i++)는 후위연산자로서 조건문을 빠져 나간다. console.log(i)에 i 값 0이 콘솔로 출력된다. 코드 블록이 실행이 종료되면서 증감식 i++가 실행되어 i = 1이된다. 조건에서 false가 나오지 않았으므로 다시 조건문으로 돌아간다. i(1) &lt; 2의 조건에 true. (i++)는 후위연산자로서 조건문을 빠져 나간다. console.log(i)에 i 값 1이 콘솔로 출력된다. 코드 블록이 실행이 종료되면서 증감식 i++가 실행되어 i = 2이된다. 다시 조건문으로 돌아간다. i(2) &lt; 2의 조건에 false. 반복문이 종료된다. for문은 중첩 사용이 가능하다 12345678910for (var i = 1; i &lt;= 6; i++) { for (var j = 1; j &lt;= 6; j++) { if (i + j == 6) { // i + j 값이 나옴 console.log(i + j); // =&gt; 6 // i ,j 값을 배열에 넣어서 경우에 수를 보여줌 console.log([i + j]); // =&gt; [1,5], [2,4], [3,3]... } }} 3.2 while 문주어진 조건에 평가가 참이면 실행, 거짓이면 종료 하지만, 불리언 값이 아니면 강제로 변환하여 논리적 참, 거짓으로 구별한다. 1234567891011var count = 0;// count가 3보다 작을때 까지만 실행.while (count &lt;= 3.5) { count++; console.log(count); if (count == 4) { break; console.log(count); }} // =&gt; 0,1,2,3,4 while의 조건으로 3.5를 주었지만, if문으로 4라는 값을 break 걸었으므로 마지막 값은 4가 나온다. 1234567var count = 0;// count가 3보다 작을때 까지만 실행.while (count &lt;= 3.5) { count++; console.log(count);} 위에 if 문에 브레이크가 4에서 값을 끊어주었다고 생각했지만, console.log가 증가 연산자(++) 뒤에 위치해서 발생한 문제었다. count 값 3이 whlie 문을 돌고 마지막으로 증가 연산자를 통해 최종적인 값이 4로 도출된다. 1234567var count = 0;// count가 3보다 작을때 까지만 실행.while (count &lt;= 3.5) { console.log(count); count++;} 즉 console.log를 증가 연산자 앞에 써주어야 원하는 값을 반환 받을수 있다. 3.3 do…while 문코드 블록을 먼저 실행하고 조건식을 평가한다. 즉 코드틑 무조건 한번 이상 실행이된다. 123456var count = 0;// count가 3보다 작을때 까지 반복 실행해라do { console.log(count); count++;} while (count &lt; 3); // =&gt; 0,1,2 4. Break 문블록 코드는 모드 제어문 환경에서 코드 탈출을 할 수 없다. 레이블 문, 반복문, switch 문의 코드 블록을 탈출한다. 코드 블록 이외에 break 문을 사용하면 syntaxError(문법에러)가 발생한다. 5. Continue 문반복문의 코드 블록 실행을 현 지점에서 중단하고 반복문의 증감식으로 이동한다.","link":"/2019/05/03/TIL-190503/"},{"title":"TIL-190528","text":"30일차 (0528) - JavascriptJavascript - What I learn… 이벤트 이벤트(Event)1. Introduction사용자가 버튼을 클릭하거나 타입을 입력한 경우 발생하는 이벤트를 제어할 수 있도록 처리해 주어야 한다. 이를 이밴트 핸들러라고 하며, 함수로 연결되어 이벤트가 발생했을때 적적한 반응을 실행한다. 2. 이벤트 루프(Event Loop)와 동시성(Concurrency)브라우저는 single-thread 에서 event-driven 방식으로 동작한다. single-thread는 하나의 작업(task)만 처리할 수 있다. 그러나 이벤트 루프(event loop)의 동시성(Concurrency)을 지원하여 동시에 많은 작업을 하는것 처럼 보인다. Call Stack (호출 스택)자바스크립트는 하나에 콜 스택을 가지고 있다. 콜 스택은 작업이 요청되면 순차적으로 실행이 된다. 만약 만은 요청이 있다면, 먼저 요청된 task가 종료되기 전까지 다른 작업을 할 수 없다. Heap동적으로 생성된 객체 인스턴스가 할당되는 영역 Event Queue (Task Queue)콜백 함수가 보관되는 영역으로 이벤트 루프(Event Loop)로 콜 스택이 비워졋을 때 순차적으로 실행된다. ]비동식: 처리 함수: 콜백 함수, 이벤트 핸들러, timer 함수(setTime(), setInterval())] 3. 이벤트의 종류3.1 UI Event Event Description load 웹페이지의 로드가 완료되었을 때. unload 웹페이지가 언로드될 때(주로 새로운 페이지를 요청한 경우). error 브라우저가 자바스크립트 오류를 만났거나 요청한 자원이 존재하지 않는 경우. resize 브라우저 창의 크기를 조절했을 때. scroll 사용자가 페이지를 위아래로 스크롤할 때. select 텍스트를 선택했을 때. 3.2 Keyboard Event Event Description keydown 키를 누르고 있을 때. keyup 누르고 있던 키를 뗄 때. keypress 키를 누르고 뗏을 때. 3.3 Mouse Event Event Description click 마우스 버튼을 클릭했을 때 dbclick 마우스 버튼을 더블 클릭했을 때 mousedown 키를 누르고 뗏을 때. mouseup 누르고 있던 마우스 버튼을 뗄 때 mousemove 마우스를 움직일 때 (터치스크린에서 동작하지 않는다) mouseover 마우스를 요소 위로 움직였을 때 (터치스크린에서 동작하지 않는다) mouseout 마우스를 요소 밖으로 움직였을 때 (터치스크린에서 동작하지 않는다) 3.4 Focus Event Event Description focus/focusin 요소가 포커스를 얻었을 때 blur/foucusout 요소가 포커스를 잃었을 때 3.5 Form Event Event Description input input 또는 textarea 요소의 값이 변경되었을 때 change select box, checkbox, radio button의 상태가 변경되었을 때 submit form을 submit할 때 (버튼 또는 키) reset reset 버튼을 클릭할 때 (최근에는 사용 안함) 3.6 Clipboard Event Event Description cut 콘텐츠를 잘라내기할 때 copy 콘텐츠를 복사할 때 paste 콘텐츠를 붙여넣기할 때 4. 이벤트 핸들러 등록4.1 인라인 이벤트 핸들러 방식4.2 이벤트 핸들러 프로퍼티 방식이벤트 핸들러에 인수를 전달할 수 없다. 또한 이벤트 핸들러 플로퍼티에는 하나의 이벤트만을 바인딩할 수 있다. 4.3 addEventListener 메소드 방식 하나이상에 5. 이벤트 핸들러 함수 내부의 this5.1 인라인 이벤트 핸들러 방식5.2 이벤트 핸들러 프로퍼티 방식5.3 addEventListener 메소드 방식6. 이벤트의 흐름7. Event 객체7.1 Event Property7.1.1 Event.target이벤트를 발생시킨 타겟(요소) 7.1.2 Event.currentTarget7.1.3 Event.type7.1.4 Event.cancelable7.1.5 Event.eventPhase7.2 Event Method7.2.1 Event.preventDefault()7.2.2 Event.stopPropagation()8. Event Delegation (이벤트 위임)버블링으로 인해 자식이 이벤트를 발생 시켜도 부모가 대신 이벤트를 받아주는것 9. 기본 동작의 변경9.1 Event.preventDefault()9.2 Event.stopPropagation()9.3 preventDefault &amp; stopPropagation","link":"/2019/05/28/TIL-190528/"},{"title":"TIL-190516","text":"18일차 (0516) - JavascriptJavascript - What I learn… 전역 객체 전역 객체 (Global Object)가장 먼저 생성되는 객체이자 최상위 객체이다. 클라이언트 사이드 환경에서 window, 서버 사이드 환경에서 node.js를 의미한다. [[constructor]] 내부 메소드를 가지고 있지 않으며, new 연산자로 호출, 생성이 불가능해서 개발자 의도적으로 생성할 수 없다. 전역 객체에서 프로퍼티를 참조할 때 window를 생략할 수 있다. 전역 객체는 Object, String, Number, Boolean, Function, Array, RegExp, Date, Math, Promise의 빌트인 객체 프로퍼티를 가지고 있다. 브라우저 환경에 window 객체는 DOM, BOM, Canvas, XMLHttpRequest, Fetch, requestAnimationFrame, SVG, Web Storage, Web Component, Web Worker와 같은 클라이언트 사이드 Web API를 프로퍼티로 소유한다. var 키워드로 선언한 전역 변수와 전역 함수 그리고 선언하지 않은 변수의 값은 전약 객체에 프로퍼티가 된다. (단 let으로 선언한 전역 변수는 전역 객체 window의 프로퍼티가 아니다, 즉 window. 으로 접근할 수 없다 = let은 보이지 않는 블록 스코프) 전역 객체의 프로퍼티와 메소드는 window를 생략하여 참조, 호출할 수 있다. 12let foo = 10; // 전역 변수console.log(window.foo); // undefined 1. 전역 프로퍼티(Global property)프로그램 전역에서 사용하는 값을 나타내며, 전역 객체의 프로퍼티를 의미한다. 1.1. Infinity양 / 음의 무한대를 나타내는 숫자값이다 12345var foo = 42 / -0;console.log(foo); // -infinityconsole.log(window.foo === foo); // =&gt; trueconsole.log(typeof foo); // =&gt; number 1.2. NaNNot-a-Number의 약자로 숫자가 아님을 나타낸다. 12345678var a = 3 * 'string';console.log(a); // NaNconsole.log(window.NaN === NaN); //falseconsole.log(window.NaN); // NaNconsole.log(number('abc')); // NaN;console.log(typeof NaN); // number; 1.3. undefined원시 타입에 undefined 값을 가지고 있다. 123456var foo;console.log(foo); // undefinedconsole.log(window.undefined); // undefinedconsole.log(window.undefined === undefined); // turnconsole.log(typeof undefined); // undefined; 2. 전역 함수(Global function)전역 함수는 프로그램 전체에서 호출할 수 있는 함수로 전역 객체 메소드이다. 2.1. eval매개변수에 전달된 코드(표현식 or 문)을 나타내는 문자열을 평가, 실행하고 결과값을 반환한다. 결과값 반환 12345let x = 1;let y = 2;console.log(eval('x + y')); // 3console.log(eval('function foo(){return true;} foo();')); 스코프 수정 12345678var x = 1;function foo() { eval('var x = 2;'); console.log(x); // =&gt; 2}foo();console.log(x); // =&gt;1 일반적인 스코프는 런타임에 결정되지 않지만, eval 함수는 런타임에 스코프를 수정할 수 있다. 즉 eval 함수는 렉시컬 스코프를 동적으로 수정할 수 있다. 엄격 모드(strick mode)에서 eval 함수 12345678910var x = 1;function foo() { 'use strict'; eval('var x = 2; console.log(x);'); // =&gt; 2 console.log(x); // =&gt; 1}foo();console.log(x); // =&gt; 1 “use strict”; 통해 기존에 스코프를 수정하지 않고, 독자적 스코프를 생성한다. 또한 “use strict”;을 사용하지 않고, let, const만 사용해도 엄격 모드랑 같은 효과가 적용된다 12345678var x = 1;function foo() { eval('const x = 2; console.log(x);'); // =&gt; 2 console.log(x); // =&gt; 1}foo();console.log(x); // =&gt; 1 따라서 eval 함수는 보안에 취약하고 일반적인 코드 실행보다 처리 속도가 느리다. 즉 렉시컬 스코프는 함수 어디에서 호출했는지 보다 어디에서 정의 했는지가 더 중요하다 2.2. isFinite매개변수를 평가하여 값이 유한수인지 검사하고 숫자가 아니라면 숫자 타입으로 변환 후 결과를 불리언 타입으로 반환한다. (유효한 수인지 검사한다.) 1234567console.log(isFinite('hello')); // falseconsole.log(isFinite(infinity)); // falseconsole.log(isFinite(NaN)); // falseconsole.log(isFinite(0)); // trueconsole.log(isFinite(2e64)); // trueconsole.log(isFinite('10')); // true =&gt; \"10\" -&gt; 10console.log(isFinite(null)); // true null =&gt; 0 2.3. isNaN매개변수 값이 NaN인지 검사후 결과를 불리언 타입으로 변환한다. (숫자 타입이 아니라면 뱐환후 검사 실행) 1234567console.log(isNaN(10)); // falseconsole.log(isNaN(NaN)); // trueconsole.log(isNaN('hello')); // tureconsole.log(isNaN('10')); // false: '10' =&gt; 10console.log(isNaN(undefined)); // true: {} =&gt; NaNconsole.log(isNaN(new Data())); // false: new Data() =&gt; numconsole.log(isNaN(new Data().toString())); // true: String =&gt; NaN 2.4. parseFloat매개 변수에 전달된 문자열을 부동 소수점 숫자(floating point number)로 변환한다. 12345console.log(parseFloat('1.11')); // =&gt; 1.11// 공백은 무시된다.console.log(parseFloat(' 10.00 ')); // =&gt; 10// 공백이 있는 문자열에 첫번째 문자만 반환console.log(parseFloat('10 years')); // 10 2.5. parseInt매개변수에 값이 정수형(integer) 숫자인지 해석(parsing)하여 반환한다. (10진수로 반환) 1234567// 문자열을 10진수로 해석 반환console.log(parseInt('10.123')) // =&gt; 10// 숫자형을 문자열로 변환후 정수형으로 표시console.log(parseInt(10.123)) // =&gt; 10// 기수 (진법) 2~36를 지정및 해석console.log(parseInt('10' 2 || 8 || 16 || ...)) // =&gt; 2 , 8 , 16//=&gt; \"10\"을 2진수로 해석하고 10진수로 반환 2.6. encodeURI / decodeURI2.7. encodeURIComponent / decodeURIComponent","link":"/2019/05/16/TIL-190516/"},{"title":"TIL-190518","text":"20일차 (0518) - JavascriptJavascript - What I learn… Number 레퍼 객체 수학 상수와 함수를 위한 Math 객체 날짜와 시간을 위한 Date 객체 String 레퍼 객체 Number 레퍼 객체원시 타입 number를 다룰 때 유용한 프로퍼티와 메소드를 제공하는 래퍼(wrapper) 객체이다. 변수, 객체의 프로퍼티가 값을 숫자로 가지고 있다면, Number 객체의 프로퍼티와 메소드를 사용할 수 있다. 원시 타입은 프로퍼티나 메소드를 호출할 때 연관된 wrapper 객체로 일시적으로 변환되어 프로토타입 객체를 공유하기 때문에 wrapper 객체의 메소드를 사용할 수 있다. 1. Number Constructor1new Number(value); 숫자 타입으로 변환하여 반환한다 1Number(value); new 연산자가 없다면, Number 객체가 아닌 원시 타입 숫자를 반환한다. 숫자를 사용할 때는 원시 타입을 사용한다. 12345678var x = 123;var y = new Number(123);console.log(x == y); // trueconsole.log(x === y); // falseconsole.log(typeof x); // numberconsole.log(typeof y); // object 2. Number Property정적(static) 프로퍼티로 number 객체를 생성할 필요가 없다. Number.propertyName 2.1 Number.EPSILON ES62.2204460492503130808472633361816E-16 = 2 -52으로써 무한소수에 가깝워서 2진법으로 계산하면 오차가 발생한다. 그래서 부동소수점 계산시 사용한다 123456function isEqual(a, b) { // a,b 값을 절대값으로 반환 return Math.abs(a - b) &lt; Number.EPSILON;}console.log(isEqual(0.3, 0.3)); // trueconsole.log(Number.EPSILON); // 2.220446049250313e-16 2.2 Number.MAX_VALUE ES1자바스크립에서 가장 큰 값을 반환한다(1.7976931348623157e+308). 단 맥스를 넘는 수는 infinity 이다. 12Number.MAX_VALUE;console.log(Number.MAX_VALUE); // 1.7976931348623157e+308 2.3 Number.MIN_VALUE ES1자바스크립에서 가장 작은 값을 반환한다(5e-324). 단 min에 가장 가까운(작은) 수는 0 이다. 12Number.MIN_VALUE;console.log(Number.MIN_VALUE); // 5e-324 2.4 Number.POSITIVE_INFINITY ES1양의 무한대를 반환한다. 12var a = Number.POSITIVE_INFINITY;console.log(Number.POSITIVE_INFINITY); // Infinity 2.5 Number.NEGATIVE_INFINITY ES1음의 무한대를 반홚한다. 12var a = Number.NEGATIVE_INFINITY;console.log(Number.NEGATIVE_INFINITY); // -infinity 2.6 Number.NaN ES1숫자가 아님을 나타낸다. Number.NaN은 window.NaN 프로퍼티와 같다 3. Number Method3.1 Number.isFinite(testValue: number): =&gt; boolean ES6매개변수에 전달된 값이 정상적인 유한수인지 검사한다. 결과는 bloolean으로 반환. 숫자가 아닌 argument가 주어지면 false를 반환한다. 암묵적 형변환 하지 않는다. 3.2 Number.isInteger(testValue: number): =&gt; boolean ES6매개변수에 전달된 값이 정수(integer) 인지 검사한다. 결과는 bloolean으로 반환. 암묵적 형변환 하지 않는다. 3.3 Number.isNaN(testValue: number): =&gt; boolean ES6매개변수에 전달된 값이 NaN인지 검사한다. 결과는 bloolean으로 반환. 숫자가 아닌 argument가 주어지면 false를 반환한다. 3.4 Number.isSafeInteger(testValue: number): =&gt; boolean ES6매개변수에 전달된 값이 안전한 정수값인지 검사한다. 결과는 bloolean으로 반환. -(253 - 1)와 253 - 1 사이에 정수값을 검사하고, 암묵적 형변환 하지 않는다. 3.5 Number.prototype.toExponential(fractionDigits?: number): =&gt; string ES3대상을 지수 표기법으로 변환하여 문자열로 반환한다. 매우 큰 숫자를 표기할 때 사용하고, 10에 n승이 곱하는 형식으로 수를 나타낸다. 1a = 1.234e3; 3.6 Number.prototype.toFixed(fractionDigits?: number): =&gt; string ES3매개변수로 지정된 소숫점 자리를 반올림하여 문자열로 반환. 1234var numObj = 12345.6789;// 소숫점 이하 6자리수 유효, 나머지 반올림console.log(numObj.toFixed(6)); // '12345.678900' 3.7 Number.prototype.toPrecision(precision?: number): =&gt; string ES3매개 변수로 지정된 전체 자릿수까지 유효하도록 나머지 자릿수를 반올림하여 문자열 반환. (자릿수를 표현할 수 없는 경우 지수 표기법으로 결과 반환) 123456var numObj = 15345.6789;// 전체자리수 유효console.log(numObj.toPrecision()); // '12345.6789'// 전체 2자리수 유효, 나머지 반올림console.log(numObj.toPrecision(2)); // '1.5e+4' 3.8 Number.prototype.toString(radix?: number): =&gt; string ES1숫자를 문자열로 반환 12console.log((17).toString()); // '17'console.log((17).toString()); // '17' 3.9 Number.prototype.valueOf(): number ES1number 객체의 원시 타입 값(primitive value)을 반환한다. 수학 상수와 함수를 위한 Math 객체1. Math Property1.1 Math.PIPI 값 (π ≈ 3.141592653589793)을 반환한다. 2. Math Method2.1 Math.abs(x: number): =&gt; number (ES1)인수(argument)의 절댓값(absolute value)을 반환한다. 절댓값은 반드시 0 뽀는 양수. 1Math.abs(); 2.2 Math.round(x: number): number (ES1)인수(argument)의 소수점 이하를 반올림한 정수를 반환한다. 1Math.abs(); 2.3 Math.ceil(x: number): number (ES1)인수(argument)의 소수점 이하를 올림한 정수를 반환한다. 12Math.ceil(1.9999); //=&gt; 2Math.ceil(-1.9999); //=&gt; -1 2.4 Math.floor(x: number): number (ES1)인수(argument)의 소수점 이하를 내림한 정수를 반환한다. 12Math.ceil(1.9999); //=&gt; 1Math.ceil(-1.9999); //=&gt; -2 2.5 Math.sqrt(x: number): number (ES1)인수(argument)의 제곱근을 반환한다. 123Math.sqrt(9); //=&gt; 3Math.sqrt(-9); //=&gt; -NaNMath.sqrt(3); //=&gt; 1.7320508075688772 2.6 Math.random(): number (ES1)임의의 부동 소수점을 반환한다. 반환된 부동 소수점은 0 ~ 1 미만이다. 12345678910Math.random();// 조건// 1 ~ 100의 랜덤 정수// Math.random 에서 1 ~ 10 랜덤 수에 100을 곱한다.// 0 ~ 1에 랜덤수에 1을 더해, 1 이상에 랜덤 수로 만든다.// random.floor로 소수점 수를 정수로 바꾼다const random = Math.floor(Math.random() * 100 + 1);console.log(random); 2.7 Math.pow(x: number, y: number): number (ES1)첫번째 인수(argument)를 밑(base), 두번째 인수를 지수(exponent)로 거듭제곱 반환한다. 12Math.pow(2, 4); // 32Math.pow(2); // NaN 2.8 Math.max(…values: number[]): number (ES1)인수(argument) 중에서 가장 큰 수를 반환한다. 12345678910Math.max(1, 2, 3); // 3//배열에 맥스 찾기const arr = [55, 1, 12, 34];const maxValue = Math.max.apply(null, arr);console.log(maxValue); // 55// ES6Math.max(...arr); // 55 2.9 Math.min(…values: number[]): number (ES1) 날짜와 시간을 위한 Date 객체1. Date Constructor1.1 new Date()1.2 new Date(milliseconds)1.3 new Date(dateString)1.4 new Date(year, month[, day, hour, minute, second, millisecond])2. Date Method2.1 Date.now()2.2 Date.parse()2.3 Date.UTC()2.4 Date.prototype.getFullYear()2.5 Date.prototype.setFullYear()2.6 Date.prototype.getMonth()2.7 Date.prototype.setMonth()2.8 Date.prototype.getDate()2.9 Date.prototype.setDate()2.10 Date.prototype.getDay()2.11 Date.prototype.getHours()2.12 Date.prototype.setHours()2.13 Date.prototype.getMinutes()2.14 Date.prototype.setMinutes()2.15 Date.prototype.getSeconds()2.16 Date.prototype.setSeconds()2.17 Date.prototype.getMilliseconds()2.18 Date.prototype.setMilliseconds()2.19 Date.prototype.getTime()2.20 Date.prototype.setTime()2.21 Date.prototype.getTimezoneOffset()2.22 Date.prototype.toDateString()2.23 Date.prototype.toTimeString()3. Date Example String 레퍼 객체1. String Constructor2. String Property2.1 String.length3. String Method3.1 String.prototype.charAt(pos: number): string ES13.2 String.prototype.concat(…strings: string[]): string ES33.3 String.prototype.indexOf(searchString: string, fromIndex=0): number ES13.4 String.prototype.lastIndexOf(searchString: string, fromIndex=this.length-1): number ES13.5 String.prototype.replace(searchValue: string | RegExp, replaceValue: string): string ES33.6 String.prototype.split(separator: string | RegExp, limit?: number): string[] ES33.7 String.prototype.substring(start: number, end=this.length): string ES33.8 String.prototype.toLowerCase(): string ES13.9 String.prototype.toUpperCase(): string ES13.10 String.prototype.trim(): string ES53.11 String.prototype.repeat(count: number): string ES6","link":"/2019/05/18/TIL-190518/"}],"tags":[{"name":"html, web","slug":"html-web","link":"/tags/html-web/"}],"categories":[{"name":"Algorithm Study","slug":"Algorithm-Study","link":"/categories/Algorithm-Study/"},{"name":"TIL","slug":"TIL","link":"/categories/TIL/"},{"name":"Project","slug":"Project","link":"/categories/Project/"},{"name":"drunk_code 협업 Project","slug":"Project/drunk-code-협업-Project","link":"/categories/Project/drunk-code-협업-Project/"}]}